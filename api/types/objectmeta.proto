syntax = "proto3";

package kantaloupe.dynamia.ai.api.types;

option go_package = "github.com/dynamia-ai/kantaloupe/api/types";

// OwnerReference contains enough information to let you identify an owning
// object. An owning object must be in the same namespace as the dependent, or
// be cluster-scoped, so there is no namespace field.
message OwnerReference {
    // UID of the referent.
    // More info: http://kubernetes.io/docs/user-guide/identifiers#uids
    string uid = 1;

    // If true, this reference points to the managing controller.
    // +optional
    bool controller = 2;

    // Name of the referent.
    string name = 3;

    // Kind of the referent.
    string kind = 4;

    // API version of the referent.
    string apiVersion = 5;

    // If true, AND if the owner has the "foregroundDeletion" finalizer, then
    // the owner cannot be deleted from the key-value store until this
    // reference is removed.
    // +optional
    bool blockOwnerDeletion = 6;
}

// ObjectMeta is metadata that all persisted resources must have, which includes
// all objects users must create.
message ObjectMeta {
    // Name must be unique within a namespace. Is required when creating
    // resources, although some resources may allow a client to request the
    // generation of an appropriate name automatically. Name is primarily intended
    // for creation idempotence and configuration definition. Cannot be updated.
    // More info: http://kubernetes.io/docs/user-guide/identifiers#names
    // +optional
    string name = 1;

    // Namespace defines the space within each name must be unique. An empty
    // namespace is equivalent to the "default" namespace, but "default" is the
    // canonical representation. Not all objects are required to be scoped to a
    // namespace - the value of this field for those objects will be empty.
    //
    // Must be a DNS_LABEL.
    // Cannot be updated.
    // More info: http://kubernetes.io/docs/user-guide/namespaces
    // +optional
    string namespace = 2;

    // UID is the unique in time and space value for this object. It is typically
    // generated by the server on successful creation of a resource and is not
    // allowed to change on PUT operations.
    //
    // Populated by the system.
    // Read-only.
    // More info: http://kubernetes.io/docs/user-guide/identifiers#uids
    // +optional
    string uid = 3;

    // An opaque value that represents the internal version of this object that
    // can be used by clients to determine when objects have changed. May be used
    // for optimistic concurrency, change detection, and the watch operation on a
    // resource or set of resources. Clients must treat these values as opaque and
    // passed unmodified back to the server. They may only be valid for a
    // particular resource or set of resources.
    //
    // Populated by the system.
    // Read-only.
    // Value must be treated as opaque by clients and .
    // More info:
    // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    string resourceVersion = 4;

    // CreationTimestamp is a timestamp representing the server time when this
    // object was created. It is not guaranteed to be set in happens-before order
    // across separate operations. Clients may not set this value. It is
    // represented in RFC3339 form and is in UTC.
    //
    // Populated by the system.
    // Read-only.
    // Null for lists.
    // More info:
    // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    // +optional
    int64 creationTimestamp = 5;

    // DeletionTimestamp is RFC 3339 date and time at which this resource will be
    // deleted. This field is set by the server when a graceful deletion is
    // requested by the user, and is not directly settable by a client. The
    // resource is expected to be deleted (no longer visible from resource lists,
    // and not reachable by name) after the time in this field, once the
    // finalizers list is empty. As long as the finalizers list contains items,
    // deletion is blocked. Once the deletionTimestamp is set, this value may not
    // be unset or be set further into the future, although it may be shortened or
    // the resource may be deleted prior to this time. For example, a user may
    // request that a pod is deleted in 30 seconds. The Kubelet will react by
    // sending a graceful termination signal to the containers in the pod. After
    // that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL)
    // to the container and after cleanup, remove the pod from the API. In the
    // presence of network partitions, this object may still exist after this
    // timestamp, until an administrator or automated process can determine the
    // resource is fully terminated.
    // If not set, graceful deletion of the object has not been requested.
    //
    // Populated by the system when a graceful deletion is requested.
    // Read-only.
    // More info:
    // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    // +optional
    int64 deletionTimestamp = 6;

    // Map of string keys and values that can be used to organize and categorize
    // (scope and select) objects. May match selectors of replication controllers
    // and services.
    // More info: http://kubernetes.io/docs/user-guide/labels
    // +optional
    map<string, string> labels = 7;

    // Annotations is an unstructured key value map stored with a resource that
    // may be set by external tools to store and retrieve arbitrary metadata. They
    // are not queryable and should be preserved when modifying objects. More
    // info: http://kubernetes.io/docs/user-guide/annotations +optional
    map<string, string> annotations = 8;

    // List of objects depended by this object. If ALL objects in the list have
    // been deleted, this object will be garbage collected. If this object is
    // managed by a controller, then an entry in this list will point to this
    // controller, with the controller field set to true. There cannot be more
    // than one managing controller. +optional +patchMergeKey=uid
    // +patchStrategy=merge
    repeated OwnerReference ownerReferences = 9;
}

// A Selector is a label query over a set of resources.
message Selector {
    // matchLabels is a map of {key,value} pairs.
    map<string, string> matchLabels = 1;
}

// A label selector is a label query over a set of resources. The result of
// matchLabels and matchExpressions are ANDed. An empty label selector matches
// all objects. A null label selector matches no objects.
message LabelSelector {
    // matchLabels is a map of {key,value} pairs. A single {key,value} in the
    // matchLabels map is equivalent to an element of matchExpressions, whose key
    // field is "key", the operator is "In", and the values array contains only
    // "value". The requirements are ANDed. +optional
    map<string, string> matchLabels = 1;

    // matchExpressions is a list of label selector requirements. The requirements
    // are ANDed. +optional
    repeated LabelSelectorRequirement matchExpressions = 2;
}

// A label selector requirement is a selector that contains values, a key, and
// an operator that relates the key and values.
message LabelSelectorRequirement {
    // key is the label key that the selector applies to.
    string key = 1;

    // operator represents a key's relationship to a set of values.
    // Valid operators are In, NotIn, Exists and DoesNotExist.
    string operator = 2;

    // values is an array of string values. If the operator is In or NotIn,
    // the values array must be non-empty. If the operator is Exists or
    // DoesNotExist, the values array must be empty. This array is replaced during
    // a strategic merge patch. +optional
    repeated string values = 3;
}

// Spec to control the desired behavior of rolling update.
message RollingUpdate {
    // The maximum number of pods that can be scheduled above the desired number
    // of pods. Value can be an absolute number (ex: 5) or a percentage of desired
    // pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number
    // is calculated from percentage by rounding up. Defaults to 25%. Example:
    // when this is set to 30%, the new ReplicaSet can be scaled up immediately
    // when the rolling update starts, such that the total number of old and new
    // pods do not exceed 130% of desired pods. Once old pods have been killed,
    // new ReplicaSet can be scaled up further, ensuring that total number of pods
    // running at any time during the update is at most 130% of desired pods.
    // +optional
    string maxSurge = 1;

    // The maximum number of pods that can be unavailable during the update.
    // Value can be an absolute number (ex: 5) or a percentage of desired pods
    // (ex: 10%). Absolute number is calculated from percentage by rounding down.
    // This can not be 0 if MaxSurge is 0.
    // Defaults to 25%.
    // Example: when this is set to 30%, the old ReplicaSet can be scaled down to
    // 70% of desired pods immediately when the rolling update starts. Once new
    // pods are ready, old ReplicaSet can be scaled down further, followed by
    // scaling up the new ReplicaSet, ensuring that the total number of pods
    // available at all times during the update is at least 70% of desired pods.
    // +optional
    string maxUnavailable = 2;
}

// UpdateStrategy indicates the strategy that the controller
// will use to perform updates. It includes any additional parameters necessary
// to perform the update for the indicated strategy.
message UpdateStrategy {
    // RollingUpdate is used to communicate parameters when Type is
    // RollingUpdateType. +optional
    RollingUpdate rollingUpdate = 1;

    // Type indicates the type of the UpdateStrategy.
    // +optional
    string type = 2;
}

// Condition describes the state of a referent at a certain point.
message Condition {
    // Last time the condition transitioned from one status to another.
    // +optional
    string lastTransitionTime = 1;

    // Last time we got an update on a given condition.
    // +optional
    string lastUpdateTime = 2;

    // A human readable message indicating details about the transition.
    // +optional
    string message = 3;

    // The reason for the condition's last transition.
    // +optional
    string reason = 4;

    // Status of the condition, one of True, False, Unknown.
    string status = 5;

    // Type of condition.
    string type = 6;
}

// WorkloadState describes the state of
// workload(deployments/daemonsets/statefulsets)
enum WorkloadState {
    // Unspecified is only a meaningless placeholder, to avoid zero not return.
    WORKLOAD_STATE_UNSPECIFIED = 0;

    // Running shows the referent is available.
    Running = 1;

    // Deleting is when the referent will be deleted.
    Deleting = 2;

    // NotReady shows the referent is unavailable.
    Not_Ready = 3;

    // Stopped indicates that the referent has 0 ready pods.
    Stopped = 5;

    // Waiting indicates that the referent is paused.
    Waiting = 6;
}
