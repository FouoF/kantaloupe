{
  "swagger": "2.0",
  "info": {
    "title": "api/acceleratorcard/v1alpha1/acceleratorcard.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "Cluster"
    },
    {
      "name": "Core"
    },
    {
      "name": "Monitoring"
    },
    {
      "name": "Kantaloupeflow"
    },
    {
      "name": "Credential"
    },
    {
      "name": "Quota"
    },
    {
      "name": "Storage"
    },
    {
      "name": "AcceleratorCard"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/apis/kantaloupe.dynamia.ai/v1/clusters": {
      "get": {
        "summary": "ListClusters lists cluster proto resources.",
        "operationId": "Cluster_ListClusters",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListClustersResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "Name is the user-specified identifier.\nThis field may not be updated.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the cluster list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the cluster list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          }
        ],
        "tags": [
          "Cluster"
        ]
      },
      "post": {
        "summary": "IntegrateCluster integrates a cluster.",
        "operationId": "Cluster_IntegrateCluster",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "IntegrateClusterRequest requests to integrates a cluster.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1IntegrateClusterRequest"
            }
          }
        ],
        "tags": [
          "Cluster"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/kubeconfig:validate": {
      "post": {
        "summary": "ValidateKubeconfig validats whether the config is valid.",
        "operationId": "Cluster_ValidateKubeconfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ValidateKubeconfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "ValidateKubeconfigRequest defines a request for validating whether the kubeconfig is valid.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1alpha1ValidateKubeconfigRequest"
            }
          }
        ],
        "tags": [
          "Cluster"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/acceleratorcards": {
      "get": {
        "operationId": "AcceleratorCard_ListAcceleratorCard",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListAcceleratorCardsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "uuid",
            "description": "Name is the user-specified identifier.\nThis field may not be updated.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "AcceleratorCard"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/acceleratorcards/{uuid}": {
      "get": {
        "operationId": "AcceleratorCard_GetAcceleratorCard",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1AcceleratorCard"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "uuid",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "AcceleratorCard"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/credentials": {
      "get": {
        "summary": "ListCredentials lists credentials.",
        "operationId": "Credential_ListCredentials",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListCredentialsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name to query.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "type",
            "description": "Type represents the credential type filter.\n\n - CREDENTIAL_TYPE_UNSPECIFIED: The credential type is unspecified.\n - DOCKER_REGISTRY: Docker registry credential type.\n - ACCESS_KEY: Access key credential type.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "CREDENTIAL_TYPE_UNSPECIFIED",
              "DOCKER_REGISTRY",
              "ACCESS_KEY"
            ],
            "default": "CREDENTIAL_TYPE_UNSPECIFIED"
          },
          {
            "name": "namespace",
            "description": "Optional namespace to filter credentials.\nIf empty, credentials from all namespaces will be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "Credential"
        ]
      },
      "post": {
        "summary": "CreateCredential creates a credential.",
        "operationId": "Credential_CreateCredential",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1CredentialResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name where the credential should be created.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CredentialCreateCredentialBody"
            }
          }
        ],
        "tags": [
          "Credential"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/credentials/{name}": {
      "delete": {
        "summary": "DeleteCredential deletes a credential.",
        "operationId": "Credential_DeleteCredential",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name where the credential is located.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is the user-specified identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Optional namespace to specify where to delete the credential.\nIf empty, the default namespace will be used.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Credential"
        ]
      },
      "put": {
        "summary": "UpdateCredential updates a credential.",
        "operationId": "Credential_UpdateCredential",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1CredentialResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name where the credential is located.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is the user-specified identifier of the credential to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CredentialUpdateCredentialBody"
            }
          }
        ],
        "tags": [
          "Credential"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/events": {
      "get": {
        "summary": "ListClusterEvents lists all events in the specified cluster,\nregardless of namespace.",
        "operationId": "Core_ListClusterEvents",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListClusterEventsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the events belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page is current page.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size is the data number shown per page.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the data list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the data list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          },
          {
            "name": "type",
            "description": "Type is used for query, showing events of specified type.\nUse example: type=WARNING\u0026type=NORMAL.\n\n - EVENT_TYPE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - Normal: Normal is a normal event type.\n - Warning: Warning is a warning event type.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "EVENT_TYPE_UNSPECIFIED",
                "Normal",
                "Warning"
              ]
            },
            "collectionFormat": "multi"
          },
          {
            "name": "kind",
            "description": "Kind is used for query, showing events of specified involvedObject kind,\ne.g. Node.\n+optional",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is used for query, showing events of specified involvedObject name,\ne.g. nodeâ€˜s name when kind is Node.\n+optional",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/gpusummary": {
      "get": {
        "summary": "ListClusterGPUSummary lists gpu summary of all nodes of the specified cluster.",
        "operationId": "Core_ListClusterGPUSummary",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListClusterGPUSummaryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "cluster defines the cluster name.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/kantaloupeflows": {
      "post": {
        "summary": "CreateKaantaloupeflow create a kantaloupeflow",
        "operationId": "Kantaloupeflow_CreateKantaloupeflow",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1Kantaloupeflow"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/KantaloupeflowCreateKantaloupeflowBody"
            }
          }
        ],
        "tags": [
          "Kantaloupeflow"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/monitoring/gpuUtilization": {
      "get": {
        "operationId": "Monitoring_ListAllPodsGPUUtilization",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListMonitoringsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "podName",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "podNamespace",
            "description": "The namespace of the monitoring.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "gpuUuid",
            "description": "gpu uuid",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "nodeName",
            "description": "The node name of the monitoring.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "modelName",
            "description": "gpu card name , eg: Tesla V100-SXM2-16GB",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the cluster list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the cluster list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespace/{namespace}/kantaloupeflow/{name}/memory/distribution": {
      "get": {
        "operationId": "Monitoring_GetKantaloupeflowMemoryDistribution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1MemoryDistributionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces": {
      "get": {
        "summary": "ListClusterNamespaces gets all the namespaces of given cluster",
        "operationId": "Core_ListClusterNamespaces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListClusterNamespacesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the namespace list belong to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workspaceId",
            "description": "workspace_id the specified namespace belongs to.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "workspaceAlias",
            "description": "workspace_alias the specified namespace belongs to.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is to filter namespaces by namespace name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the job list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the job list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          },
          {
            "name": "labelSelector",
            "description": "LabelSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fieldSelector",
            "description": "FieldSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuzzyName",
            "description": "FuzzyName is used to fuzzy search by cluster name or cluster alias name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "phase",
            "description": "Phases is used for filter.\n\n - NAMESPACE_PHASE_UNSPECIFIED: The namespace state is unspecified.\n - Active: NamespaceActive means the namespace is available for use in the system\n - Terminating: NamespaceTerminating means the namespace is undergoing graceful termination",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "NAMESPACE_PHASE_UNSPECIFIED",
              "Active",
              "Terminating"
            ],
            "default": "NAMESPACE_PHASE_UNSPECIFIED"
          },
          {
            "name": "excludeSystem",
            "description": "ExcludeSystem determines to exclude system namespaces, defaults to False.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/configmaps/{name}": {
      "get": {
        "summary": "GetConfigMap gets a configMap under the namespaces of a specific cluster",
        "operationId": "Core_GetConfigMap",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ConfigMap"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster represents which cluster the configMaps belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace is the metadata.namespace of the referenced configmap.\nThis field is required in all cases.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "ConfigMap name.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      },
      "put": {
        "summary": "UpdateConfigMap updates a configMap under the namespaces of a specific cluster",
        "operationId": "Core_UpdateConfigMap",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1UpdateConfigMapResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the specified configmap belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace is the metadata.namespace of the referenced ConfigMap.\nThis field is required in all cases.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "name represents for the resource name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CoreUpdateConfigMapBody"
            }
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/configmaps/{name}/json": {
      "get": {
        "summary": "GetConfigMapJSON gets a configMap json under the namespaces of a specific cluster",
        "operationId": "Core_GetConfigMapJSON",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1GetConfigMapJSONResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster represents which cluster the configmap belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace is the metadata.namespace of the referenced ConfigMap.\nThis field is required in all cases.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "name represents for the resource name",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/events": {
      "get": {
        "summary": "ListEvents lists events under the namespaces of a specific cluster",
        "operationId": "Core_ListEvents",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListEventsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "cluster represents the name of deployment belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace represents which namespace the deployment belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "kind",
            "description": "Kind represents what type of event is needed.\n\n - KIND_UNSPECIFIED: KIND_UNSPECIFIED is only a meaningless placeholder, to avoid zero not\nreturn.\n - Deployment: ListEvents by deployment.\n - StatefulSet: ListEvents by statefulSet.\n - DaemonSet: ListEvents by daemonSet.\n - Pod: ListEvents by pod.\n - Service: ListEvents by service.\n - Ingress: ListEvents by ingress.\n - Job: ListEvents by job.\n - CronJob: ListEvents by cronJob.\n - HorizontalPodAutoscaler: ListEvents by HorizontalPodAutoscaler.\n - ReplicaSet: ListEvents by replicaset.\n - CronHPA: ListEvents by CronHPA.\n - PersistentVolumeClaim: ListEvents by PersistentVolumeClaim.\n - GroupVersionResource: ListEvents by GroupVersionResource. If kind is set to GroupVersionResource,\nyou must specify the value of group version resource.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "KIND_UNSPECIFIED",
              "Deployment",
              "StatefulSet",
              "DaemonSet",
              "Pod",
              "Service",
              "Ingress",
              "Job",
              "CronJob",
              "HorizontalPodAutoscaler",
              "ReplicaSet",
              "CronHPA",
              "PersistentVolumeClaim",
              "GroupVersionResource"
            ],
            "default": "KIND_UNSPECIFIED"
          },
          {
            "name": "kindName",
            "description": "The name of involvedObject.\nIf the kind is DEPLOYMENT,\nthis presents the name of deployments.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name stands for event name, used for fuzzy search.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the event list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the event list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          },
          {
            "name": "type",
            "description": "Type is used for query, showing events of specified type.\nUse example: type=WARNING\u0026type=NORMAL.\n\n - EVENT_TYPE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - Normal: Normal is a normal event type.\n - Warning: Warning is a warning event type.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "EVENT_TYPE_UNSPECIFIED",
                "Normal",
                "Warning"
              ]
            },
            "collectionFormat": "multi"
          },
          {
            "name": "group",
            "description": "resource group,used when the kind type is GroupVersionResource.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "version",
            "description": "resource version,used when the kind type is GroupVersionResource.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "resource",
            "description": "resource name,used when the kind type is GroupVersionResource.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/kantaloupeflows": {
      "get": {
        "summary": "ListKantaloupeflows lists Kantaloupeflow",
        "operationId": "Kantaloupeflow_ListKantaloupeflows",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListKantaloupeflowsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is the user-specified identifier.\nThis field may not be updated.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the cluster list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the cluster list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          }
        ],
        "tags": [
          "Kantaloupeflow"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/kantaloupeflows/{name}": {
      "get": {
        "summary": "GetKantaloupeflow get a specified Kantaloupeflow",
        "operationId": "Kantaloupeflow_GetKantaloupeflow",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1Kantaloupeflow"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Kantaloupeflow"
        ]
      },
      "delete": {
        "summary": "DeleteKantaloupeflow delete a specified Kantaloupeflow",
        "operationId": "Kantaloupeflow_DeleteKantaloupeflow",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Kantaloupeflow"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/kantaloupeflows/{name}/gpumemory": {
      "post": {
        "summary": "UpdateKantaloupeflowGPUMemory update Kantaloupeflow gpu memory. Unit is MB.",
        "operationId": "Kantaloupeflow_UpdateKantaloupeflowGPUMemory",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/KantaloupeflowUpdateKantaloupeflowGPUMemoryBody"
            }
          }
        ],
        "tags": [
          "Kantaloupeflow"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/kantaloupeflows/{name}/resource/trend": {
      "get": {
        "summary": "GetKantaloupeflowResourceTrend returns the resource utilization trend for a specific kantalouepflow",
        "operationId": "Monitoring_GetKantaloupeflowResourceTrend",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ResourceTrendResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "The cluster to query",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "The namespace to query",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "The name to query",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "resourceType",
            "description": "The type of resource to query",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "RESOURCE_TYPE_UNSPECIFIED",
              "RESOURCE_TYPE_CPU",
              "RESOURCE_TYPE_MEMORY",
              "RESOURCE_TYPE_GPU_CORE",
              "RESOURCE_TYPE_GPU_MEMORY",
              "RESOURCE_TYPE_STORAGE",
              "RESOURCE_TYPE_NETWORK"
            ],
            "default": "RESOURCE_TYPE_UNSPECIFIED"
          },
          {
            "name": "range",
            "description": "Optional: relative time range (e.g. \"1h\")",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "start",
            "description": "Optional: start time in seconds since epoch",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "end",
            "description": "Optional: end time in seconds since epoch",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/quotas": {
      "post": {
        "summary": "CreateQuota creates a resource quota.",
        "operationId": "Quota_CreateQuota",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1QuotaResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name where the quota should be created.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace to create the quota in.\nIf empty, the default namespace will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/QuotaCreateQuotaBody"
            }
          }
        ],
        "tags": [
          "Quota"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/quotas/{name}": {
      "delete": {
        "summary": "DeleteQuota deletes a resource quota.",
        "operationId": "Quota_DeleteQuota",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name where the quota is located.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Optional namespace to specify where to delete the quota.\nIf empty, the default namespace will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is the user-specified identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Quota"
        ]
      },
      "put": {
        "summary": "UpdateQuota updates a resource quota.",
        "operationId": "Quota_UpdateQuota",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1QuotaResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name where the quota is located.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace where the quota is located.\nIf empty, the default namespace will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is the user-specified identifier of the quota to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/QuotaUpdateQuotaBody"
            }
          }
        ],
        "tags": [
          "Quota"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/secrets": {
      "post": {
        "summary": "CreateSecret creates a secret under the namespaces of a specific cluster",
        "operationId": "Core_CreateSecret",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1CreateSecretResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster represents which cluster the secret belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "When the current namespace is named, the priority is higher than that in yaml",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CoreCreateSecretBody"
            }
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/namespaces/{namespace}/secrets/{name}": {
      "get": {
        "summary": "GetClusterSecret gets a secret under the namespaces of a specific cluster",
        "operationId": "Core_GetSecret",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1Secret"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster represents which cluster the secret belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace is the metadata.namespace of the referenced secret.\nThis field is required in all cases.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Secret name.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      },
      "delete": {
        "summary": "DeleteSecret deletes a secret under the namespaces of a specific cluster",
        "operationId": "Core_DeleteSecret",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster represents which cluster the secret belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace is the metadata.namespace of the referenced secret.\nThis field is required in all cases.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Secret name.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/nodeWorkloads/top": {
      "get": {
        "summary": "Get top K nodes by workload count",
        "operationId": "Monitoring_GetTopNodeWorkloads",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1TopNodeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/nodes": {
      "get": {
        "summary": "ListNodes lists nodes under the specific node",
        "operationId": "Core_ListNodes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apicorev1alpha1ListNodesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Name is the user-specified identifier.\nThis field may not be updated.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the cluster list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the cluster list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/nodes/top": {
      "get": {
        "summary": "Get top K nodes by resource usage",
        "operationId": "Monitoring_GetTopNodes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1TopNodeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "resourceType",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "RESOURCE_TYPE_UNSPECIFIED",
              "RESOURCE_TYPE_CPU",
              "RESOURCE_TYPE_MEMORY",
              "RESOURCE_TYPE_GPU_CORE",
              "RESOURCE_TYPE_GPU_MEMORY",
              "RESOURCE_TYPE_STORAGE",
              "RESOURCE_TYPE_NETWORK"
            ],
            "default": "RESOURCE_TYPE_UNSPECIFIED"
          },
          {
            "name": "rankingType",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "RANKING_TYPE_UNSPECIFIED",
              "RANKING_TYPE_ALLOCATED",
              "RANKING_TYPE_USED"
            ],
            "default": "RANKING_TYPE_UNSPECIFIED"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/nodes/{name}": {
      "get": {
        "summary": "GetNode gets the details of the specified node",
        "operationId": "Core_GetNode",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apicorev1alpha1Node"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name is the user-specified identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/nodes/{node}/resource/trend": {
      "get": {
        "summary": "GetNodeResourceTrend returns the resource utilization trend for a specific node",
        "operationId": "Monitoring_GetNodeResourceTrend",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ResourceTrendResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "The cluster to query",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "node",
            "description": "The node to query",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "resourceType",
            "description": "The type of resource to query",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "RESOURCE_TYPE_UNSPECIFIED",
              "RESOURCE_TYPE_CPU",
              "RESOURCE_TYPE_MEMORY",
              "RESOURCE_TYPE_GPU_CORE",
              "RESOURCE_TYPE_GPU_MEMORY",
              "RESOURCE_TYPE_STORAGE",
              "RESOURCE_TYPE_NETWORK"
            ],
            "default": "RESOURCE_TYPE_UNSPECIFIED"
          },
          {
            "name": "range",
            "description": "Optional: relative time range (e.g. \"1h\")",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "start",
            "description": "Optional: start time in seconds since epoch",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "end",
            "description": "Optional: end time in seconds since epoch",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/nodes/{node}/workloads/distribution": {
      "get": {
        "summary": "GetNodeWorkloadDistribution returns the workload distribution for a specific node",
        "operationId": "Monitoring_GetNodeWorkloadDistribution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1WorkloadDistributionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "The cluster to query",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "node",
            "description": "The node to query",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/persistentvolumes": {
      "get": {
        "summary": "ListPersistentVolumes lists persistentvolumes in the specified cluster",
        "operationId": "Core_ListPersistentVolumes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListPersistentVolumesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the PersistentVolumes belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name stands for PersistentVolume name, used for fuzzy search.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the PersistentVolume list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the PersistentVolume list order.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "labelSelector",
            "description": "LabelSelector is the format after labels.FormatLabels used to filter.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fieldSelector",
            "description": "FieldSelector is the format after labels.FormatLabels used to filter.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuzzyName",
            "description": "FuzzyName is used to fuzzy search by cluster name or cluster alias name.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      },
      "post": {
        "summary": "CreatePersistentVolume creates a persistentvolume to the system by given persistentvolume data",
        "operationId": "Core_CreatePersistentVolume",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1CreatePersistentVolumeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the specified persistentVolume belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CoreCreatePersistentVolumeBody"
            }
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/persistentvolumes/{name}": {
      "get": {
        "summary": "GetPersistentVolume gets a persistentvolume from the system by given persistentvolume name",
        "operationId": "Core_GetPersistentVolume",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1GetPersistentVolumeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the specified persistentVolume belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name of the specified persistentVolume.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      },
      "delete": {
        "summary": "DeletePersistentVolume deletes a persistentvolume from the system by given persistentvolume name",
        "operationId": "Core_DeletePersistentVolume",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster represents which cluster the PersistentVolume belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name represents for the PersistentVolume name.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      },
      "put": {
        "summary": "UpdatePersistentVolume updates a persistentvolume from the system by given persistentvolume name",
        "operationId": "Core_UpdatePersistentVolume",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1UpdatePersistentVolumeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the specified persistentVolume belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name of the specified persistentVolume.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CoreUpdatePersistentVolumeBody"
            }
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/persistentvolumes/{name}/json": {
      "get": {
        "summary": "GetPersistentVolumeJSON gets a persistentvolume json from the system by given persistentvolume name",
        "operationId": "Core_GetPersistentVolumeJSON",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1GetPersistentVolumeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster the specified persistentVolume belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "description": "Name represents for the persistentVolume name.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/quotas": {
      "get": {
        "summary": "ListQuotas lists resource quotas.",
        "operationId": "Quota_ListQuotas",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListQuotasResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster is the cluster name to query.\nIf empty, the local cluster will be used.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Optional namespace to filter quotas.\nIf empty, quotas from all namespaces will be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "Quota"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/resource/trend": {
      "get": {
        "summary": "GetResourceTrend returns the resource utilization trend for a specific resource type",
        "operationId": "Monitoring_GetResourceTrend",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ResourceTrendResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "The cluster to query",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "resourceType",
            "description": "The type of resource to query",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "RESOURCE_TYPE_UNSPECIFIED",
              "RESOURCE_TYPE_CPU",
              "RESOURCE_TYPE_MEMORY",
              "RESOURCE_TYPE_GPU_CORE",
              "RESOURCE_TYPE_GPU_MEMORY",
              "RESOURCE_TYPE_STORAGE",
              "RESOURCE_TYPE_NETWORK"
            ],
            "default": "RESOURCE_TYPE_UNSPECIFIED"
          },
          {
            "name": "range",
            "description": "Optional: relative time range (e.g. \"1h\")",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "start",
            "description": "Optional: start time in seconds since epoch",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          },
          {
            "name": "end",
            "description": "Optional: end time in seconds since epoch",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/secrets": {
      "get": {
        "summary": "ListSecrets lists a secret under the namespaces of a specific cluster",
        "operationId": "Core_ListSecrets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListSecretsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "Cluster represents which cluster the secret belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "namespace",
            "description": "Namespace is the metadata.namespace of the referenced secret.\nThis field is required in all cases.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "name",
            "description": "The name use to search specific secret",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          },
          {
            "name": "labelSelector",
            "description": "LabelSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fieldSelector",
            "description": "FieldSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "type",
            "description": "Type is used to filter secrets by type.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "onlyMetadata",
            "description": "OnlyMetadata lists only metadata of secrets, default false.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "fuzzyName",
            "description": "FuzzyName is used to fuzzy search by multiple parameters including name.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Core"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/storage": {
      "delete": {
        "summary": "DeleteStorage deletes a storage",
        "operationId": "Storage_DeleteStorage",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "namespace",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Storage"
        ]
      },
      "post": {
        "summary": "CreateStorageClass creates a storage",
        "operationId": "Storage_CreateStorage",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1Storage"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/StorageCreateStorageBody"
            }
          }
        ],
        "tags": [
          "Storage"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/storage/{namespace}": {
      "get": {
        "summary": "ListStorage lists specific namespace storage",
        "operationId": "Storage_ListStorages",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListStoragesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "cluster represents the name of PVC to belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "namespace",
            "description": "Namespace represents which namespace the PVC belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "name",
            "description": "Name is used for fuzzy search by name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "phase",
            "description": "Phases is used for fuzzy search by phase.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          },
          {
            "name": "labelSelector",
            "description": "LabelSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fieldSelector",
            "description": "FieldSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuzzyName",
            "description": "FuzzyName is used to fuzzy search by multiple parameters including name.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "isManage",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "Storage"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/storageclasses": {
      "get": {
        "summary": "ListStorageClasses lists storage classes.",
        "operationId": "Storage_ListStorageClasses",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ListStorageClassesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "cluster represents the name of PVC to belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "page",
            "description": "Page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "pageSize",
            "description": "Size per page requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "name",
            "description": "Name is used for filter.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "sortBy",
            "description": "SortBy determines the list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "SORT_BY_UNSPECIFIED",
              "field_name",
              "created_at"
            ],
            "default": "SORT_BY_UNSPECIFIED"
          },
          {
            "name": "sortDir",
            "description": "OrderBy determines the list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "desc",
              "asc"
            ],
            "default": "desc"
          },
          {
            "name": "labelSelector",
            "description": "LabelSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fieldSelector",
            "description": "FieldSelector is the format after labels.FormatLabels used to filter",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "provisioner",
            "description": "Provisioner is used for fuzzy search by provisioner.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "reclaimPolicy",
            "description": "ReclaimPolicy is used for fuzzy search by reclaimPolicy.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "fuzzyName",
            "description": "FuzzyName is used to fuzzy search by multiple parameters including name.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Storage"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{cluster}/workloads/distribution": {
      "get": {
        "summary": "GetClusterWorkloadDistribution returns the workload distribution across the cluster",
        "operationId": "Monitoring_GetClusterWorkloadDistribution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1WorkloadDistributionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "cluster",
            "description": "The cluster to query",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/clusters/{name}": {
      "get": {
        "summary": "GetCluster gets the details of the specified cluster.",
        "operationId": "Cluster_GetCluster",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "Name is the user-specified identifier.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Cluster"
        ]
      },
      "delete": {
        "summary": "DeleteCluster deletes the specified cluster.",
        "operationId": "Cluster_DeleteCluster",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "type": "object",
              "properties": {}
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "Name is the user-specified identifier.\nThis field may not be updated.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ClusterDeleteClusterBody"
            }
          }
        ],
        "tags": [
          "Cluster"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/plateform/kantaloupeflows/tree": {
      "get": {
        "operationId": "Kantaloupeflow_GetKantaloupeTree",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1KantaloupeTree"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "tags": [
          "Kantaloupeflow"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/plateform/resource/trend": {
      "get": {
        "operationId": "Monitoring_GetPlateformResourceTrend",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1ResourceTrendResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "tags": [
          "Monitoring"
        ]
      }
    },
    "/apis/kantaloupe.dynamia.ai/v1/plateform/summury": {
      "get": {
        "summary": "GetPlateformSummury gets plateform summury.",
        "operationId": "Cluster_GetPlateformSummury",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1alpha1PlatformSummury"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "tags": [
          "Cluster"
        ]
      }
    }
  },
  "definitions": {
    "ClusterDeleteClusterBody": {
      "type": "object",
      "description": "DeleteClusterRequest defines a request for deleting a cluster."
    },
    "CoreCreatePersistentVolumeBody": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1PersistentVolume",
          "description": "Data is the persistentVolume YAML details."
        }
      },
      "description": "Create PersistentVolume in the cluster."
    },
    "CoreCreateSecretBody": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1Secret",
          "title": "The data is the Secret YAML details"
        }
      },
      "description": "Create Secret in the cluster."
    },
    "CoreUpdateConfigMapBody": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "title": "data The data field is the ConfigMap YAML details"
        }
      }
    },
    "CoreUpdatePersistentVolumeBody": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1PersistentVolume",
          "description": "Data is the persistentVolume YAML details."
        }
      },
      "description": "Update PersistentVolume in the cluster."
    },
    "CredentialCreateCredentialBody": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the user-specified identifier for the credential."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace to create the credential in.\nIf empty, the default namespace will be used."
        },
        "type": {
          "$ref": "#/definitions/v1alpha1CredentialType",
          "description": "Type indicates the type of credential being created."
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Data contains the credential-specific data.\nFor DOCKER_REGISTRY:\n- required: server, username, password\nFor ACCESS_KEY:\n- required: accessKey, secretKey"
        }
      },
      "description": "CreateCredentialRequest defines a request for creating a credential."
    },
    "CredentialUpdateCredentialBody": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace where the credential is located.\nIf empty, the default namespace will be used."
        },
        "type": {
          "$ref": "#/definitions/v1alpha1CredentialType",
          "description": "Type indicates the type of credential being updated."
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Data contains the updated credential-specific data.\nFor DOCKER_REGISTRY:\n- required: server, username, password\nFor ACCESS_KEY:\n- required: accessKey, secretKey"
        }
      },
      "description": "UpdateCredentialRequest defines a request for updating a credential."
    },
    "KantaloupeflowCreateKantaloupeflowBody": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1Kantaloupeflow"
        }
      }
    },
    "KantaloupeflowUpdateKantaloupeflowGPUMemoryBody": {
      "type": "object",
      "properties": {
        "gpumemory": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "ListEventsRequestKind": {
      "type": "string",
      "enum": [
        "KIND_UNSPECIFIED",
        "Deployment",
        "StatefulSet",
        "DaemonSet",
        "Pod",
        "Service",
        "Ingress",
        "Job",
        "CronJob",
        "HorizontalPodAutoscaler",
        "ReplicaSet",
        "CronHPA",
        "PersistentVolumeClaim",
        "GroupVersionResource"
      ],
      "default": "KIND_UNSPECIFIED",
      "description": " - KIND_UNSPECIFIED: KIND_UNSPECIFIED is only a meaningless placeholder, to avoid zero not\nreturn.\n - Deployment: ListEvents by deployment.\n - StatefulSet: ListEvents by statefulSet.\n - DaemonSet: ListEvents by daemonSet.\n - Pod: ListEvents by pod.\n - Service: ListEvents by service.\n - Ingress: ListEvents by ingress.\n - Job: ListEvents by job.\n - CronJob: ListEvents by cronJob.\n - HorizontalPodAutoscaler: ListEvents by HorizontalPodAutoscaler.\n - ReplicaSet: ListEvents by replicaset.\n - CronHPA: ListEvents by CronHPA.\n - PersistentVolumeClaim: ListEvents by PersistentVolumeClaim.\n - GroupVersionResource: ListEvents by GroupVersionResource. If kind is set to GroupVersionResource,\nyou must specify the value of group version resource."
    },
    "NodeStatusRole": {
      "type": "string",
      "enum": [
        "NODE_ROLE_UNSPECIFIED",
        "CONTROL_PLANE",
        "WORKER"
      ],
      "default": "NODE_ROLE_UNSPECIFIED",
      "description": "Role includes control-plane and worker.\n\n - NODE_ROLE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - CONTROL_PLANE: The control plane manages the worker nodes and the Pods in the cluster.\n - WORKER: The worker node(s) host the Pods that are the components of the\napplication workload."
    },
    "PersistentVolumeClaimSpecVolumeMode": {
      "type": "string",
      "enum": [
        "VOLUME_MODE_UNSPECIFIED",
        "Block",
        "Filesystem"
      ],
      "default": "VOLUME_MODE_UNSPECIFIED",
      "description": " - Block: PersistentVolumeBlock means the volume will not be formatted with a filesystem and will remain a raw block device.\n - Filesystem: PersistentVolumeFilesystem means the volume will be or is formatted with a filesystem."
    },
    "QuotaCreateQuotaBody": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the user-specified identifier for the quota."
        },
        "hard": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Hard contains resource names and their maximum allowed values."
        }
      },
      "description": "CreateQuotaRequest defines a request for creating a quota."
    },
    "QuotaUpdateQuotaBody": {
      "type": "object",
      "properties": {
        "hard": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Hard contains resource names and their maximum allowed values."
        }
      },
      "description": "UpdateQuotaRequest defines a request for updating a quota."
    },
    "StorageClassReclaimPolicy": {
      "type": "string",
      "enum": [
        "RECLAIM_AOLICY_UNSPECIFIED",
        "Delete",
        "Retain"
      ],
      "default": "RECLAIM_AOLICY_UNSPECIFIED",
      "description": " - Delete: PersistentVolumeReclaimDelete means the volume will be deleted from Kubernetes on release from its claim.\nThe volume plugin must support Deletion.\n - Retain: PersistentVolumeReclaimRetain means the volume will be left in its current phase (Released) for manual reclamation by the administrator.\nThe default policy is Retain."
    },
    "StorageClassVolumeBindingMode": {
      "type": "string",
      "enum": [
        "VOLUME_BINDING_MODE_UNSPECIFIED",
        "Immediate",
        "WaitForFirstConsumer"
      ],
      "default": "VOLUME_BINDING_MODE_UNSPECIFIED",
      "description": " - Immediate: VolumeBindingImmediate indicates that PersistentVolumeClaims should be\nimmediately provisioned and bound.  This is the default mode.\n - WaitForFirstConsumer: VolumeBindingWaitForFirstConsumer indicates that PersistentVolumeClaims\nshould not be provisioned and bound until the first Pod is created that\nreferences the PeristentVolumeClaim.  The volume provisioning and\nbinding will occur during Pod scheduing."
    },
    "StorageCreateStorageBody": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1PersistentVolume"
        },
        "storageType": {
          "$ref": "#/definitions/v1alpha1StorageType"
        },
        "isManage": {
          "type": "boolean"
        }
      }
    },
    "apicorev1alpha1HostPathVolumeSource": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "apicorev1alpha1ListNodesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicorev1alpha1Node"
          },
          "title": "data The data field is the YAML details"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "Nodes information List."
    },
    "apicorev1alpha1Node": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "spec": {
          "$ref": "#/definitions/v1alpha1NodeSpec",
          "description": "NodeSpec defines the behavior of a node."
        },
        "status": {
          "$ref": "#/definitions/apicorev1alpha1NodeStatus",
          "description": "Most recently observed status of the node.\nPopulated by the system."
        }
      }
    },
    "apicorev1alpha1NodeStatus": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1alpha1NodeStatusStatus",
          "description": "Status represents the current information/status of node."
        },
        "addresses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1NodeAddress"
          },
          "description": "IP Address reachable to the node."
        },
        "cpuCapacity": {
          "type": "string",
          "format": "int64",
          "description": "CpuCapacity is the total cpu of the node. Unit: m."
        },
        "cpuAllocated": {
          "type": "number",
          "format": "double",
          "description": "CpuAllocated is the total pod cpu request on the node. Unit: %."
        },
        "cpuUsage": {
          "type": "number",
          "format": "double",
          "description": "CpuUsage is the cpu usage on the node. Unit: %."
        },
        "memoryCapacity": {
          "type": "string",
          "format": "int64",
          "description": "MemoryCapacity is the total memory of the node. Unit: byte."
        },
        "memoryAllocated": {
          "type": "number",
          "format": "double",
          "description": "MemoryAllocated is the total pod memory request on the node. Unit: %."
        },
        "memoryUsage": {
          "type": "number",
          "format": "double",
          "description": "MemoryUsage is the memory usage on the node. Unit: %."
        },
        "gpuCoreTotal": {
          "type": "integer",
          "format": "int32",
          "description": "gpu_total is gpu total number."
        },
        "gpuCoreAllocated": {
          "type": "integer",
          "format": "int32",
          "description": "gpu_allocated is gpu allocated number."
        },
        "gpuCoreUsage": {
          "type": "integer",
          "format": "int32",
          "title": "gpu_core_usage is the usage rate of gpu"
        },
        "gpuMemoryTotal": {
          "type": "string",
          "format": "int64",
          "description": "gpu_memory_total is all gpu memory number with node. Unit: byte."
        },
        "gpuMemoryAllocated": {
          "type": "string",
          "format": "int64",
          "title": "gpu_memory_allocated is allocated gpu memory number with node. Unit: byte"
        },
        "gpuMemoryUsage": {
          "type": "string",
          "format": "int64",
          "title": "gpu_memory_usage is the usage rate of gpu video memory"
        },
        "systemInfo": {
          "$ref": "#/definitions/v1alpha1NodeSystemInfo",
          "description": "Set of ids/uuids to uniquely identify the node."
        },
        "roles": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/NodeStatusRole"
          },
          "description": "The roles of current node."
        }
      },
      "description": "NodeStatus is information about the current status of a node."
    },
    "apicorev1alpha1ResourceList": {
      "type": "object",
      "properties": {
        "storage": {
          "type": "string",
          "description": "Storage is the total storage resource. Unit: byte."
        }
      },
      "description": "ResourceList returns a string representation of a resource list in a human\nreadable format."
    },
    "apicorev1alpha1ResourceRequirements": {
      "type": "object",
      "properties": {
        "limits": {
          "$ref": "#/definitions/apicorev1alpha1ResourceList",
          "title": "Limits describes the maximum amount of compute resources allowed.\nMore info:\nhttps://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n+optional"
        },
        "requests": {
          "$ref": "#/definitions/apicorev1alpha1ResourceList",
          "title": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is\nexplicitly specified, otherwise to an implementation-defined value. More\ninfo:\nhttps://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n+optional"
        }
      },
      "description": "ResourceRequirements describes the compute resource requirements."
    },
    "apikantaloupeflowv1alpha1HostPathVolumeSource": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "Path of the directory on the host.\nIf the path is a symlink, it will follow the link to the real path."
        },
        "type": {
          "type": "string",
          "title": "Type for HostPath Volume\nDefaults to \"\"\n+optional"
        }
      },
      "description": "HostPathVolumeSource Represents a host path mapped into a pod.\nHost path volumes do not support ownership management or SELinux relabeling."
    },
    "apikantaloupeflowv1alpha1ResourceList": {
      "type": "object",
      "properties": {
        "cpu": {
          "type": "string",
          "description": "Cpu is the total pod cpu resource. Unit: m."
        },
        "memory": {
          "type": "string",
          "description": "Memory is the total memory resource. Unit: byte."
        },
        "storage": {
          "type": "string",
          "description": "Storage is the total storage resource. Unit: byte."
        },
        "resources": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Resources contains all resources include cpu, memory, storage."
        }
      },
      "description": "ResourceList returns a string representation of a resource list in a human\nreadable format."
    },
    "apikantaloupeflowv1alpha1ResourceRequirements": {
      "type": "object",
      "properties": {
        "limits": {
          "$ref": "#/definitions/apikantaloupeflowv1alpha1ResourceList",
          "title": "Limits describes the maximum amount of compute resources allowed.\nMore info:\nhttps://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n+optional"
        },
        "requests": {
          "$ref": "#/definitions/apikantaloupeflowv1alpha1ResourceList",
          "title": "Requests describes the minimum amount of compute resources required.\nIf Requests is omitted for a container, it defaults to Limits if that is\nexplicitly specified, otherwise to an implementation-defined value. More\ninfo:\nhttps://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\n+optional"
        }
      },
      "description": "ResourceRequirements describes the compute resource requirements."
    },
    "corev1alpha1Phase": {
      "type": "string",
      "enum": [
        "PHASE_UNSPECIFIED",
        "Pending",
        "Available",
        "Bound",
        "Released",
        "Failed"
      ],
      "default": "PHASE_UNSPECIFIED",
      "title": "- Pending: used for PersistentVolumes that are not available\n - Available: used for PersistentVolumes that are not yet bound\nAvailable volumes are held by the binder and matched to PersistentVolumeClaims\n - Bound: used for PersistentVolumes that are bound\n - Released: used for PersistentVolumes where the bound PersistentVolumeClaim was deleted\nreleased volumes must be recycled before becoming available again\nthis phase is used by the persistent volume claim binder to signal to another process to reclaim the resource\n - Failed: used for PersistentVolumes that failed to be correctly recycled or deleted after being released from a claim"
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "typesCondition": {
      "type": "object",
      "properties": {
        "lastTransitionTime": {
          "type": "string",
          "title": "Last time the condition transitioned from one status to another.\n+optional"
        },
        "lastUpdateTime": {
          "type": "string",
          "title": "Last time we got an update on a given condition.\n+optional"
        },
        "message": {
          "type": "string",
          "title": "A human readable message indicating details about the transition.\n+optional"
        },
        "reason": {
          "type": "string",
          "title": "The reason for the condition's last transition.\n+optional"
        },
        "status": {
          "type": "string",
          "description": "Status of the condition, one of True, False, Unknown."
        },
        "type": {
          "type": "string",
          "description": "Type of condition."
        }
      },
      "description": "Condition describes the state of a referent at a certain point."
    },
    "typesConditionStatus": {
      "type": "string",
      "enum": [
        "CONDITION_STATUS_UNSPECIFIED",
        "True",
        "False",
        "Unknown"
      ],
      "default": "CONDITION_STATUS_UNSPECIFIED",
      "description": "These are valid condition statuses.\n\n - CONDITION_STATUS_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - True: True means a resource is in the condition.\n - False: False means a resource is not in the condition.\n - Unknown: Unknown means kubernetes can't decide if a resource is in the condition or\nnot."
    },
    "typesLabelSelector": {
      "type": "object",
      "properties": {
        "matchLabels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "matchLabels is a map of {key,value} pairs. A single {key,value} in the\nmatchLabels map is equivalent to an element of matchExpressions, whose key\nfield is \"key\", the operator is \"In\", and the values array contains only\n\"value\". The requirements are ANDed. +optional"
        },
        "matchExpressions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/typesLabelSelectorRequirement"
          },
          "title": "matchExpressions is a list of label selector requirements. The requirements\nare ANDed. +optional"
        }
      },
      "description": "A label selector is a label query over a set of resources. The result of\nmatchLabels and matchExpressions are ANDed. An empty label selector matches\nall objects. A null label selector matches no objects."
    },
    "typesLabelSelectorRequirement": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "key is the label key that the selector applies to."
        },
        "operator": {
          "type": "string",
          "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist."
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or\nDoesNotExist, the values array must be empty. This array is replaced during\na strategic merge patch. +optional"
        }
      },
      "description": "A label selector requirement is a selector that contains values, a key, and\nan operator that relates the key and values."
    },
    "typesObjectMeta": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name must be unique within a namespace. Is required when creating\nresources, although some resources may allow a client to request the\ngeneration of an appropriate name automatically. Name is primarily intended\nfor creation idempotence and configuration definition. Cannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#names\n+optional"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace defines the space within each name must be unique. An empty\nnamespace is equivalent to the \"default\" namespace, but \"default\" is the\ncanonical representation. Not all objects are required to be scoped to a\nnamespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL.\nCannot be updated.\nMore info: http://kubernetes.io/docs/user-guide/namespaces\n+optional"
        },
        "uid": {
          "type": "string",
          "description": "UID is the unique in time and space value for this object. It is typically\ngenerated by the server on successful creation of a resource and is not\nallowed to change on PUT operations.\n\nPopulated by the system.\nRead-only.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids\n+optional"
        },
        "resourceVersion": {
          "type": "string",
          "description": "An opaque value that represents the internal version of this object that\ncan be used by clients to determine when objects have changed. May be used\nfor optimistic concurrency, change detection, and the watch operation on a\nresource or set of resources. Clients must treat these values as opaque and\npassed unmodified back to the server. They may only be valid for a\nparticular resource or set of resources.\n\nPopulated by the system.\nRead-only.\nValue must be treated as opaque by clients and .\nMore info:\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"
        },
        "creationTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "CreationTimestamp is a timestamp representing the server time when this\nobject was created. It is not guaranteed to be set in happens-before order\nacross separate operations. Clients may not set this value. It is\nrepresented in RFC3339 form and is in UTC.\n\nPopulated by the system.\nRead-only.\nNull for lists.\nMore info:\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "deletionTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "DeletionTimestamp is RFC 3339 date and time at which this resource will be\ndeleted. This field is set by the server when a graceful deletion is\nrequested by the user, and is not directly settable by a client. The\nresource is expected to be deleted (no longer visible from resource lists,\nand not reachable by name) after the time in this field, once the\nfinalizers list is empty. As long as the finalizers list contains items,\ndeletion is blocked. Once the deletionTimestamp is set, this value may not\nbe unset or be set further into the future, although it may be shortened or\nthe resource may be deleted prior to this time. For example, a user may\nrequest that a pod is deleted in 30 seconds. The Kubelet will react by\nsending a graceful termination signal to the containers in the pod. After\nthat 30 seconds, the Kubelet will send a hard termination signal (SIGKILL)\nto the container and after cleanup, remove the pod from the API. In the\npresence of network partitions, this object may still exist after this\ntimestamp, until an administrator or automated process can determine the\nresource is fully terminated.\nIf not set, graceful deletion of the object has not been requested.\n\nPopulated by the system when a graceful deletion is requested.\nRead-only.\nMore info:\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n+optional"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: http://kubernetes.io/docs/user-guide/labels\n+optional"
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Annotations is an unstructured key value map stored with a resource that\nmay be set by external tools to store and retrieve arbitrary metadata. They\nare not queryable and should be preserved when modifying objects. More\ninfo: http://kubernetes.io/docs/user-guide/annotations +optional"
        },
        "ownerReferences": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/typesOwnerReference"
          },
          "title": "List of objects depended by this object. If ALL objects in the list have\nbeen deleted, this object will be garbage collected. If this object is\nmanaged by a controller, then an entry in this list will point to this\ncontroller, with the controller field set to true. There cannot be more\nthan one managing controller. +optional +patchMergeKey=uid\n+patchStrategy=merge"
        }
      },
      "description": "ObjectMeta is metadata that all persisted resources must have, which includes\nall objects users must create."
    },
    "typesOwnerReference": {
      "type": "object",
      "properties": {
        "uid": {
          "type": "string",
          "title": "UID of the referent.\nMore info: http://kubernetes.io/docs/user-guide/identifiers#uids"
        },
        "controller": {
          "type": "boolean",
          "title": "If true, this reference points to the managing controller.\n+optional"
        },
        "name": {
          "type": "string",
          "description": "Name of the referent."
        },
        "kind": {
          "type": "string",
          "description": "Kind of the referent."
        },
        "apiVersion": {
          "type": "string",
          "description": "API version of the referent."
        },
        "blockOwnerDeletion": {
          "type": "boolean",
          "title": "If true, AND if the owner has the \"foregroundDeletion\" finalizer, then\nthe owner cannot be deleted from the key-value store until this\nreference is removed.\n+optional"
        }
      },
      "description": "OwnerReference contains enough information to let you identify an owning\nobject. An owning object must be in the same namespace as the dependent, or\nbe cluster-scoped, so there is no namespace field."
    },
    "typesPagination": {
      "type": "object",
      "properties": {
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total is the total number of referents."
        },
        "page": {
          "type": "integer",
          "format": "int32",
          "description": "Page is current page."
        },
        "pageSize": {
          "type": "integer",
          "format": "int32",
          "description": "PageSize is the data number shown per page."
        },
        "pages": {
          "type": "integer",
          "format": "int32",
          "description": "Pages is the number of pages."
        }
      },
      "description": "Pagination is for data paging."
    },
    "typesSortBy": {
      "type": "string",
      "enum": [
        "SORT_BY_UNSPECIFIED",
        "field_name",
        "created_at"
      ],
      "default": "SORT_BY_UNSPECIFIED",
      "description": "SortBy determines the data list order reference.\n\n - SORT_BY_UNSPECIFIED: Unspecified is default, no sorting.\n - field_name: Sort result by name.\n - created_at: Sort result by creationTimestamp."
    },
    "typesSortDir": {
      "type": "string",
      "enum": [
        "desc",
        "asc"
      ],
      "default": "desc",
      "description": "SortDir determines the data list order.\n\n - desc: Desc stands for descending order.\n - asc: Asc stands for ascending order."
    },
    "v1alpha1AcceleraorCardSummuray": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string"
        },
        "totalNum": {
          "type": "integer",
          "format": "int32"
        },
        "useageNum": {
          "type": "integer",
          "format": "int32"
        },
        "idelNum": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1alpha1AcceleratorCard": {
      "type": "object",
      "properties": {
        "uuid": {
          "type": "string"
        },
        "node": {
          "type": "string"
        },
        "model": {
          "type": "string"
        },
        "state": {
          "type": "string"
        },
        "temperature": {
          "type": "number",
          "format": "double"
        },
        "power": {
          "type": "number",
          "format": "double"
        },
        "provider": {
          "$ref": "#/definitions/v1alpha1ClusterProvider",
          "description": "Provider represents the cloud provider name of the member cluster."
        },
        "gpuCoreTotal": {
          "type": "integer",
          "format": "int32",
          "description": "gpu_total is gpu total number."
        },
        "gpuCoreAllocated": {
          "type": "integer",
          "format": "int32",
          "description": "gpu_allocated is gpu allocated number."
        },
        "gpuCoreUsage": {
          "type": "integer",
          "format": "int32",
          "title": "gpu_core_usage is the usage rate of gpu"
        },
        "gpuMemoryTotal": {
          "type": "string",
          "format": "int64",
          "description": "gpu_memory_total is all gpu memory number with node. Unit: byte."
        },
        "gpuMemoryAllocated": {
          "type": "string",
          "format": "int64",
          "title": "gpu_memory_allocated is allocated gpu memory number with node. Unit: byte"
        },
        "gpuMemoryUsage": {
          "type": "string",
          "format": "int64",
          "title": "gpu_memory_usage is the usage rate of gpu video memory"
        }
      }
    },
    "v1alpha1Cluster": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "spec": {
          "$ref": "#/definitions/v1alpha1ClusterSpec",
          "description": "ClusterSpec describes how the cluster execution will look like and when it\nwill actually run."
        },
        "status": {
          "$ref": "#/definitions/v1alpha1ClusterStatus",
          "description": "ClusterStatus contains the cluster status. The ClusterStatus will be stored\nin the kubeadm-config ConfigMap in the cluster, and then updated by kubeadm\nwhen additional control plane instance joins or leaves the cluster."
        }
      }
    },
    "v1alpha1ClusterProvider": {
      "type": "string",
      "enum": [
        "CLUSTER_PROVIDER_UNSPECIFIED",
        "GENERIC",
        "REDHAT_OPENSHIFT4",
        "SUSE_RANCHER",
        "VMWARE_TANZU",
        "AWS_EKS",
        "ALIYUN_ACK",
        "HUAWEI_CCE"
      ],
      "default": "CLUSTER_PROVIDER_UNSPECIFIED",
      "description": " - CLUSTER_PROVIDER_UNSPECIFIED: The cluster provider is unspecified.\n - GENERIC: Generic\nGENERIC indicates other providers\n - REDHAT_OPENSHIFT4: OverSea Distribtion\nREDHAT_OPENSHIFT4 indicates a provider of RedHat Openshift4\n - SUSE_RANCHER: SUSE_RANCHER indicates a provider of SUSE Rancher\n - VMWARE_TANZU: VMWARE_TANZU indicates a provider of VMware Tanzu\n - AWS_EKS: Public Cloud\nAWS_EKS indicates a provider of AWS EKS\n - ALIYUN_ACK: ALIYUN_ACK indicates a provider of Aliyun ACK\n - HUAWEI_CCE: TENCENT_TKE indicates a provider of Huawei CCE."
    },
    "v1alpha1ClusterSpec": {
      "type": "object",
      "properties": {
        "provider": {
          "$ref": "#/definitions/v1alpha1ClusterProvider",
          "description": "Provider represents the cloud provider name of the member cluster."
        },
        "type": {
          "$ref": "#/definitions/v1alpha1ClusterType",
          "description": "ClusterType represents the type of cluster."
        },
        "apiEndpoint": {
          "type": "string",
          "description": "The API endpoint of the member cluster. This can be a hostname,\nhostname:port, IP or IP:port."
        },
        "region": {
          "type": "string",
          "description": "Region represents the region of the member cluster locate in."
        },
        "zone": {
          "type": "string",
          "description": "Zone represents the zone of the member cluster locate in."
        },
        "aliasName": {
          "type": "string",
          "description": "AliasName represents the alias of the cluster."
        },
        "prometheusAddress": {
          "type": "string",
          "description": "PrometheusAddress represents the address of prometheus for the cluster."
        },
        "gatewayAddress": {
          "type": "string",
          "description": "GatewayAddress represents the address of gateway for the apiserver."
        }
      }
    },
    "v1alpha1ClusterStatus": {
      "type": "object",
      "properties": {
        "kubernetesVersion": {
          "type": "string",
          "description": "KubernetesVersion represents version of the member cluster."
        },
        "kubeSystemID": {
          "type": "string",
          "description": "KubeSystemId represents the uuid of sub cluster kube-system namespace."
        },
        "clusterVersion": {
          "type": "string",
          "description": "ClusterVersion represents the version of the member cluster."
        },
        "nodeSummary": {
          "$ref": "#/definitions/v1alpha1ResourceSummary",
          "description": "ResourceSummary represents the node of the member cluster."
        },
        "podSummary": {
          "$ref": "#/definitions/v1alpha1ResourceSummary",
          "description": "ResourceSummary represents the pod of the member cluster."
        },
        "kantaloupeflowSummary": {
          "$ref": "#/definitions/v1alpha1ResourceSummary",
          "description": "ResourceSummary represents the kantaloupeflow of the member cluster."
        },
        "cpuUsage": {
          "type": "number",
          "format": "double",
          "description": "The cpu usage of the member cluster."
        },
        "memoryUsage": {
          "type": "number",
          "format": "double",
          "description": "The memory usage of the member cluster."
        },
        "gpuTotal": {
          "type": "integer",
          "format": "int32"
        },
        "gpuMemoryTotal": {
          "type": "string",
          "format": "int64"
        },
        "cpuTotal": {
          "type": "integer",
          "format": "int32"
        },
        "memoryTotal": {
          "type": "string",
          "format": "int64"
        },
        "gpuCoreUsage": {
          "type": "number",
          "format": "double"
        },
        "gpuMemoryUsage": {
          "type": "number",
          "format": "double"
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/typesCondition"
          },
          "description": "Current condition of cluster."
        }
      }
    },
    "v1alpha1ClusterType": {
      "type": "string",
      "enum": [
        "CLUSTER_TYPE_UNSPECIFIED",
        "NVIDIA",
        "METAX",
        "CAMBRICON",
        "MORE_THREADS",
        "LLUVATAR_COREX",
        "HYGON",
        "ASCEND"
      ],
      "default": "CLUSTER_TYPE_UNSPECIFIED",
      "description": " - CLUSTER_TYPE_UNSPECIFIED: The cluster type is unspecified.\n - NVIDIA: nvidia\nNVIDIA indicates the cluster type of NVIDIA.\n - METAX: MetaX\nMETAX indicates the cluster type of MetaX.\n - CAMBRICON: Cambricon\nMETAX indicates the cluster type of cambricon.\n - MORE_THREADS: More threads\nMETAX indicates the cluster type of more threads.\n - LLUVATAR_COREX: lluvatar corex\nlluvatar corex indicates the cluster type of lluvatar corex.\n - HYGON: hygon\nHYGON corex indicates the cluster type of hygon.\n - ASCEND: ascend\nASCEND indicates the cluster type of ascend."
    },
    "v1alpha1ConfigMap": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "immutable": {
          "type": "boolean",
          "title": "Immutable, if set to true, ensures that data stored in the ConfigMap cannot\nbe updated (only object metadata can be modified).\nIf not set to true, the field can be modified at any time.\nDefaulted to nil.\n+optional"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Data contains the configuration data.\nEach key must consist of alphanumeric characters, '-', '_' or '.'.\nValues with non-UTF-8 byte sequences must use the BinaryData field.\nThe keys stored in Data must not overlap with the keys in\nthe BinaryData field, this is enforced during validation process.\n+optional"
        },
        "binaryData": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "byte"
          },
          "title": "BinaryData contains the binary data.\nEach key must consist of alphanumeric characters, '-', '_' or '.'.\nBinaryData can contain byte sequences that are not in the UTF-8 range.\nThe keys stored in BinaryData must not overlap with the ones in\nthe Data field, this is enforced during validation process.\nUsing this field will require 1.10+ apiserver and\nkubelet.\n+optional"
        }
      }
    },
    "v1alpha1ConfigMapVolumeSource": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1KeyToPath"
          },
          "title": "If unspecified, each key-value pair in the Data field of the referenced\nConfigMap will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the ConfigMap,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.\n+optional"
        },
        "defaultMode": {
          "type": "integer",
          "format": "int32",
          "title": "Optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0\nand 511. YAML accepts both octal and decimal values, JSON requires decimal\nvalues for mode bits. Defaults to 0644. Directories within the path are not\naffected by this setting. This might be in conflict with other options that\naffect the file mode, like fsGroup, and the result can be other mode bits\nset. +optional"
        },
        "optional": {
          "type": "boolean",
          "title": "Specify whether the ConfigMap or its keys must be defined\n+optional"
        }
      },
      "description": "Adapts a ConfigMap into a volume.\n\nThe contents of the target ConfigMap's Data field will be presented in a\nvolume as files using the keys in the Data field as the file names, unless\nthe items element is populated with specific mappings of keys to paths.\nConfigMap volumes support ownership management and SELinux relabeling."
    },
    "v1alpha1Container": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of Container."
        },
        "image": {
          "type": "string",
          "description": "The used image of Container."
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The container command."
        },
        "args": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "workingDir": {
          "type": "string"
        },
        "ports": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Ports"
          }
        },
        "env": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1EnvVar"
          },
          "description": "EnvVar represents an environment variable present in a Container."
        },
        "resources": {
          "$ref": "#/definitions/apikantaloupeflowv1alpha1ResourceRequirements",
          "description": "Source represents a source for the value of an EnvVar."
        },
        "volumeMounts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1VolumeMount"
          },
          "description": "VolumeMount describes a mounting of a Volume within a container."
        },
        "imagePullPolicy": {
          "type": "string",
          "description": "Pull image policy."
        }
      }
    },
    "v1alpha1CreatePersistentVolumeResponse": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1PersistentVolume",
          "description": "Data is the PersistentVolume YAML details."
        }
      },
      "description": "CreatePersistentVolumeResponse returns the created PersistentVolume data information."
    },
    "v1alpha1CreateSecretResponse": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1Secret",
          "title": "The data is the Secret YAML details"
        }
      },
      "description": "It returns the created Secret data information."
    },
    "v1alpha1CredentialResponse": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the credential name."
        },
        "type": {
          "$ref": "#/definitions/v1alpha1CredentialType",
          "description": "Type is the credential type."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace where the credential is located."
        },
        "createdTime": {
          "type": "string",
          "format": "int64",
          "description": "CreatedTime is the creation timestamp."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels attached to the credential."
        }
      },
      "description": "CredentialResponse represents a credential response without sensitive data."
    },
    "v1alpha1CredentialType": {
      "type": "string",
      "enum": [
        "CREDENTIAL_TYPE_UNSPECIFIED",
        "DOCKER_REGISTRY",
        "ACCESS_KEY"
      ],
      "default": "CREDENTIAL_TYPE_UNSPECIFIED",
      "description": "CredentialType represents the type of credential.\n\n - CREDENTIAL_TYPE_UNSPECIFIED: The credential type is unspecified.\n - DOCKER_REGISTRY: Docker registry credential type.\n - ACCESS_KEY: Access key credential type."
    },
    "v1alpha1DistributionPoint": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "The name of the category (e.g. \"GPU-1\" or \"0-10\")"
        },
        "value": {
          "type": "integer",
          "format": "int32",
          "title": "The value for this category"
        }
      },
      "title": "DistributionPoint represents a single point in a distribution"
    },
    "v1alpha1DistributionPoint64": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1alpha1EmptyDirVolumeSource": {
      "type": "object",
      "properties": {
        "medium": {
          "type": "string",
          "title": "What type of storage medium should back this directory.\nThe default is \"\" which means to use the node's default medium.\nMust be an empty string (default) or Memory.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir\n+optional"
        },
        "sizeLimit": {
          "type": "string",
          "format": "int64",
          "title": "Total amount of local storage required for this EmptyDir volume.\nThe size limit is also applicable for memory medium.\nThe maximum usage on memory medium EmptyDir would be the minimum value\nbetween the SizeLimit specified here and the sum of memory limits of all\ncontainers in a pod. The default is nil which means that the limit is\nundefined. More info: http://kubernetes.io/docs/user-guide/volumes#emptydir\n+optional"
        }
      },
      "description": "Represents an empty directory for a pod.\nEmpty directory volumes support ownership management and SELinux relabeling."
    },
    "v1alpha1EnvVar": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of EnvVar."
        },
        "value": {
          "type": "string",
          "description": "The value of EnvVar."
        }
      },
      "description": "Environment variable information."
    },
    "v1alpha1Event": {
      "type": "object",
      "properties": {
        "involvedObject": {
          "$ref": "#/definitions/v1alpha1ObjectReference",
          "description": "The object that this event is about."
        },
        "reason": {
          "type": "string",
          "description": "reason is why the action was taken. It is human-readable.\nThis field cannot be empty for new Events and it can have at most 128\ncharacters."
        },
        "message": {
          "type": "string",
          "description": "A human-readable description of the status of this operation."
        },
        "source": {
          "$ref": "#/definitions/v1alpha1EventSource",
          "description": "The component reporting this event. Should be a short machine\nunderstandable string."
        },
        "lastTimestamp": {
          "type": "string",
          "format": "int64",
          "description": "The time at which the most recent occurrence of this event was recorded."
        },
        "type": {
          "$ref": "#/definitions/v1alpha1EventType",
          "description": "Type of this event (Normal, Warning), new types could be added in the\nfuture."
        },
        "firstTimestamp": {
          "type": "string",
          "format": "int64"
        }
      },
      "description": "Event is a report of an event somewhere in the cluster.  Events\nhave a limited retention time and triggers and messages may evolve\nwith time.  Event consumers should not rely on the timing of an event\nwith a given Reason reflecting a consistent underlying trigger, or the\ncontinued existence of events with that Reason.  Events should be\ntreated as informative, best-effort, supplemental data."
    },
    "v1alpha1EventSource": {
      "type": "object",
      "properties": {
        "component": {
          "type": "string",
          "title": "Component from which the event is generated.\n+optional"
        },
        "host": {
          "type": "string",
          "title": "Node name on which the event is generated.\n+optional"
        }
      },
      "description": "EventSource contains information for an event."
    },
    "v1alpha1EventType": {
      "type": "string",
      "enum": [
        "EVENT_TYPE_UNSPECIFIED",
        "Normal",
        "Warning"
      ],
      "default": "EVENT_TYPE_UNSPECIFIED",
      "description": "Type of event (Normal, Warning), new types could be added in the\nfuture.\n\n - EVENT_TYPE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - Normal: Normal is a normal event type.\n - Warning: Warning is a warning event type."
    },
    "v1alpha1GPUSummary": {
      "type": "object",
      "properties": {
        "node": {
          "type": "string",
          "description": "node defines the cluster node name."
        },
        "vgpuTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "vgpu_types defines a array restore vGPU types of the node."
        }
      }
    },
    "v1alpha1GetConfigMapJSONResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "title": "The data is the ConfigMap YAML details"
        }
      },
      "description": "ConfigMap data information in json format."
    },
    "v1alpha1GetPersistentVolumeResponse": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1PersistentVolume",
          "description": "The data is the persistentVolume YAML details."
        }
      }
    },
    "v1alpha1IntegrateClusterRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the user-specified identifier.\nThis field may not be updated."
        },
        "aliasName": {
          "type": "string",
          "description": "It is an alias given by the user and can be changed at will. It cannot be\nempty."
        },
        "provider": {
          "$ref": "#/definitions/v1alpha1ClusterProvider",
          "description": "Provider represents the cloud provider name of the member cluster."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels are key/value pairs that are attached to objects."
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations to attach arbitrary metadata to objects."
        },
        "describe": {
          "type": "string",
          "description": "describe represents the details of the member cluster."
        },
        "kubeConfig": {
          "type": "string",
          "description": "kubeConfig of the cluster."
        },
        "prometheusAddress": {
          "type": "string",
          "description": "prometheusAddress represents the address of prometheus for the cluster."
        },
        "type": {
          "$ref": "#/definitions/v1alpha1ClusterType",
          "description": "ClusterType represents the type of cluster."
        }
      },
      "description": "IntegrateClusterRequest requests to integrates a cluster."
    },
    "v1alpha1KantaloupeTree": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1KantaloupeTreeNode"
          }
        }
      }
    },
    "v1alpha1KantaloupeTreeNode": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "name represents the cluster name."
        },
        "value": {
          "type": "integer",
          "format": "int32"
        },
        "children": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1KantaloupeTreeNode"
          }
        }
      }
    },
    "v1alpha1Kantaloupeflow": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "spec": {
          "$ref": "#/definitions/v1alpha1KantaloupeflowSpec"
        },
        "status": {
          "$ref": "#/definitions/v1alpha1KantaloupeflowStatus"
        }
      }
    },
    "v1alpha1KantaloupeflowSpec": {
      "type": "object",
      "properties": {
        "plugins": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1PluginType"
          }
        },
        "replicas": {
          "type": "integer",
          "format": "int32"
        },
        "template": {
          "$ref": "#/definitions/v1alpha1PodTemplateSpec"
        },
        "paused": {
          "type": "boolean"
        },
        "workload": {
          "$ref": "#/definitions/v1alpha1WorkloadType"
        }
      }
    },
    "v1alpha1KantaloupeflowState": {
      "type": "string",
      "enum": [
        "KANTALOUPEFLOW_STATE_UNSPECIFIED",
        "Unknow",
        "Progressing",
        "Running",
        "Falied"
      ],
      "default": "KANTALOUPEFLOW_STATE_UNSPECIFIED",
      "description": " - KANTALOUPEFLOW_STATE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return."
    },
    "v1alpha1KantaloupeflowStatus": {
      "type": "object",
      "properties": {
        "replicas": {
          "type": "integer",
          "format": "int32",
          "title": "Total number of non-terminated pods targeted by this deployment (their labels match the selector).\n+optional"
        },
        "readyReplicas": {
          "type": "integer",
          "format": "int32",
          "title": "readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.\n+optional"
        },
        "networks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Network"
          },
          "description": "Network info for jupyter, vscode."
        },
        "state": {
          "$ref": "#/definitions/v1alpha1KantaloupeflowState",
          "description": "KantaloupeflowState is kantaloupeflow state."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/typesCondition"
          },
          "description": "Conditions is an array of current conditions."
        }
      }
    },
    "v1alpha1KeyToPath": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "The key to project."
        },
        "path": {
          "type": "string",
          "description": "The relative path of the file to map the key to.\nMay not be an absolute path.\nMay not contain the path element '..'.\nMay not start with the string '..'."
        },
        "mode": {
          "type": "integer",
          "format": "int32",
          "title": "Optional: mode bits to use on this file, should be a value between 0\nand 0777. If not specified, the volume defaultMode will be used.\nThis might be in conflict with other options that affect the file\nmode, like fsGroup, and the result can be other mode bits set.\n+optional"
        }
      },
      "description": "KeyToPath maps a string key to a path within a volume."
    },
    "v1alpha1ListAcceleratorCardsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1AcceleratorCard"
          },
          "title": "data The data field is the YAML details"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "Clusters information List."
    },
    "v1alpha1ListClusterEventsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Event"
          },
          "description": "Data represents the returned event list."
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination is for data paging."
        }
      },
      "description": "ListClusterEventsResponse returns the list and pagination of events."
    },
    "v1alpha1ListClusterGPUSummaryResponse": {
      "type": "object",
      "properties": {
        "summary": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1GPUSummary"
          },
          "description": "summary defines a array restore GUP type summary of all nodes."
        }
      }
    },
    "v1alpha1ListClusterNamespacesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Namespace"
          },
          "title": "Data is the returned namespace list"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      }
    },
    "v1alpha1ListClustersResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Cluster"
          },
          "title": "data The data field is the YAML details"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "Clusters information List."
    },
    "v1alpha1ListCredentialsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1CredentialResponse"
          },
          "description": "Items contains the list of credentials."
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "ListCredentialsResponse defines a response for listing credentials."
    },
    "v1alpha1ListEventsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Event"
          },
          "title": "Data response of the workload's event"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "title": "Pagination is for data paging"
        }
      },
      "title": "ListEventsByWorkloadNameResponse the response of listEvents by workload name"
    },
    "v1alpha1ListKantaloupeflowsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Kantaloupeflow"
          },
          "title": "data The data field is the YAML details"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "Kantaloupeflows information List."
    },
    "v1alpha1ListMonitoringsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Monitoring"
          },
          "title": "data The data field is the YAML details"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      }
    },
    "v1alpha1ListPersistentVolumesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1PersistentVolume"
          },
          "description": "Items of PersistentVolumes."
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "ListPersistentVolumesResponse returns PersistentVolume list."
    },
    "v1alpha1ListQuotasResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1QuotaResponse"
          },
          "description": "Items contains the list of quotas."
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "ListQuotasResponse defines a response for listing quotas."
    },
    "v1alpha1ListSecretsResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Secret"
          },
          "description": "Secret name."
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "description": "List of Secrets data details."
    },
    "v1alpha1ListStorageClassesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1StorageClass"
          },
          "title": "Data describes the common attributes of storage devices\nand allows a Source for provider-specific attributes"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "title": "ListPersistentVolumeClaimsRequest represents the response of list storage class"
    },
    "v1alpha1ListStoragesResponse": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Storage"
          },
          "title": "Data describes the common attributes of storage devices\nand allows a Source for provider-specific attributes"
        },
        "pagination": {
          "$ref": "#/definitions/typesPagination",
          "description": "Pagination returned contains current page, size, and total."
        }
      },
      "title": "ListPersistentVolumeClaimRequest represents the response of list PVC"
    },
    "v1alpha1LocalVolumeSource": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string"
        },
        "fsType": {
          "type": "string"
        }
      }
    },
    "v1alpha1MemoryDistributionResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1DistributionPoint64"
          }
        }
      },
      "title": "MemoryDistributionResponse represents the gpu memory distribution of a workload"
    },
    "v1alpha1Monitoring": {
      "type": "object",
      "properties": {
        "podName": {
          "type": "string",
          "description": "The name of the monitoring."
        },
        "podNamespace": {
          "type": "string",
          "description": "The namespace of the monitoring."
        },
        "gpuUuid": {
          "type": "string",
          "title": "gpu uuid"
        },
        "nodeName": {
          "type": "string",
          "description": "The node name of the monitoring."
        },
        "gpuUtilization": {
          "type": "number",
          "format": "float"
        },
        "modelName": {
          "type": "string",
          "title": "gpu card name , eg: Tesla V100-SXM2-16GB"
        }
      },
      "description": "Monitoring represents a monitoring."
    },
    "v1alpha1NFSVolumeSource": {
      "type": "object",
      "properties": {
        "server": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "readOnly": {
          "type": "boolean"
        }
      }
    },
    "v1alpha1Namespace": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "spec": {
          "$ref": "#/definitions/v1alpha1NamespaceSpec",
          "description": "NamespaceSpec describes how the namespace execution will look like and when\nit will actually run."
        },
        "status": {
          "$ref": "#/definitions/v1alpha1NamespaceStatus",
          "title": "Status describes the current status of a Namespace.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n+optional"
        }
      },
      "description": "Namespace provides a scope for Names."
    },
    "v1alpha1NamespacePhase": {
      "type": "string",
      "enum": [
        "NAMESPACE_PHASE_UNSPECIFIED",
        "Active",
        "Terminating"
      ],
      "default": "NAMESPACE_PHASE_UNSPECIFIED",
      "title": "- NAMESPACE_PHASE_UNSPECIFIED: The namespace state is unspecified.\n - Active: NamespaceActive means the namespace is available for use in the system\n - Terminating: NamespaceTerminating means the namespace is undergoing graceful termination"
    },
    "v1alpha1NamespaceSpec": {
      "type": "object",
      "properties": {
        "Finalizers": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "NamespaceSpec describes the attributes on a Namespace."
    },
    "v1alpha1NamespaceStatus": {
      "type": "object",
      "properties": {
        "phase": {
          "$ref": "#/definitions/v1alpha1NamespacePhase",
          "description": "Phase represents the phase of namespace."
        },
        "readyPodNumber": {
          "type": "integer",
          "format": "int32",
          "description": "ReadyPodNumber is the ready pod number on the namespace."
        },
        "totalPodNumber": {
          "type": "integer",
          "format": "int32",
          "description": "TotalPodNumber is the total pod number on the namespace."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/typesCondition"
          },
          "description": "Represents the latest available observations of a namespace's current state."
        },
        "podSecurityEnabled": {
          "type": "boolean",
          "description": "PodSecurityEnabled shows if the namespace has enabled pod security policy."
        },
        "cpuUsage": {
          "type": "number",
          "format": "double",
          "description": "The cpu usage of the member namespace."
        },
        "memoryUsage": {
          "type": "number",
          "format": "double",
          "description": "The memory usage of the member namespace."
        }
      },
      "description": "NamespaceStatus is information about the current status of a Namespace."
    },
    "v1alpha1Network": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of network, eg jupyter, vscode."
        },
        "url": {
          "type": "string",
          "title": "URL means the external access address.\nFor exposed ports, url like: 123.123.123.123:31332,\nFor jupyter and vscode, url like: http://103.12.12.12/zestu.io/user-xx/instance-xx/xx"
        }
      }
    },
    "v1alpha1NodeAddress": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Type is a array used for frontend filter."
        },
        "address": {
          "type": "string",
          "description": "IP Address reachable to the node."
        }
      },
      "description": "NodeAddress contains information for the instance's address.\nThe node addresses returned here will be set on the node's status.addresses\nfield."
    },
    "v1alpha1NodeCondition": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Type of node condition. The built-in set of conditions are: Ready,\nMemoryPressure, DiskPressure, PIDPressure,\nNetworkUnavailable, and SchedulingDisabled."
        },
        "status": {
          "$ref": "#/definitions/typesConditionStatus",
          "description": "Status of the condition, one of True, False, Unknown."
        },
        "reason": {
          "type": "string",
          "description": "(brief) reason for the condition's last transition."
        },
        "message": {
          "type": "string",
          "description": "Human readable message indicating details about last transition."
        }
      },
      "description": "NodeCondition contains condition information for a node."
    },
    "v1alpha1NodePhase": {
      "type": "string",
      "enum": [
        "NODE_PHASE_UNSPECIFIED",
        "Ready",
        "Not_Ready",
        "Unknown"
      ],
      "default": "NODE_PHASE_UNSPECIFIED",
      "description": "Phase includes Ready, NotReady, and Unknown.\n\n - NODE_PHASE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - Ready: The node is ready to work.\n - Not_Ready: The node is not ready.\n - Unknown: The node state is unknown."
    },
    "v1alpha1NodeSpec": {
      "type": "object",
      "properties": {
        "podCIDR": {
          "type": "string",
          "description": "PodCIDR represents the pod IP range assigned to the node."
        },
        "unschedulable": {
          "type": "boolean",
          "description": "Unschedulable controls node schedulability of new pods. By default, node is\nschedulable."
        },
        "taints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Taint"
          },
          "description": "If specified, the node's taints."
        }
      }
    },
    "v1alpha1NodeStatusStatus": {
      "type": "object",
      "properties": {
        "phase": {
          "$ref": "#/definitions/v1alpha1NodePhase"
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1NodeCondition"
          },
          "description": "NodeCondition contains condition information for a node."
        }
      },
      "description": "Status is the current observed node condition."
    },
    "v1alpha1NodeSystemInfo": {
      "type": "object",
      "properties": {
        "kernelVersion": {
          "type": "string",
          "description": "Kernel Version reported by the node from 'uname -r'\n(e.g. 3.16.0-0.bpo.4-amd64)."
        },
        "osImage": {
          "type": "string",
          "description": "OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7\n(wheezy))."
        },
        "containerRuntimeVersion": {
          "type": "string",
          "description": "ContainerRuntime Version reported by the node through runtime remote API\n(e.g. docker://1.5.0)."
        },
        "kubeletVersion": {
          "type": "string",
          "description": "Kubelet Version reported by the node."
        },
        "architecture": {
          "type": "string",
          "description": "The Architecture reported by the node."
        },
        "cudaVersion": {
          "type": "string"
        },
        "nvidiaVersion": {
          "type": "string"
        }
      }
    },
    "v1alpha1ObjectReference": {
      "type": "object",
      "properties": {
        "kind": {
          "type": "string",
          "title": "Kind of the referent.\nMore info:\nhttps://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n+optional"
        },
        "name": {
          "type": "string",
          "title": "Name of the referent.\nMore info:\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        },
        "namespace": {
          "type": "string",
          "title": "Namespace of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\n+optional"
        },
        "uid": {
          "type": "string",
          "title": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids\n+optional"
        },
        "apiVersion": {
          "type": "string",
          "title": "API version of the referent.\n+optional"
        },
        "resourceVersion": {
          "type": "string",
          "title": "Specific resourceVersion to which this reference is made, if any.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency\n+optional"
        }
      },
      "description": "ObjectReference contains enough information to let you inspect or modify the\nreferred object."
    },
    "v1alpha1PersistentVolume": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "spec": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeSpec",
          "description": "Spec defines a specification of a persistent volume owned by the cluster."
        },
        "status": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeStatus",
          "title": "PersistentVolumeClaimStatus represents the status of PV claim"
        }
      },
      "title": "PersistentVolume (PV) is a storage resource provisioned by an administrator.\nIt is analogous to a node.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes"
    },
    "v1alpha1PersistentVolumeAccessMode": {
      "type": "string",
      "enum": [
        "PERSISTENT_VOLUME_ACCESS_MODE_UNSPECIFIED",
        "ReadWriteOnce",
        "ReadOnlyMany",
        "ReadWriteMany",
        "ReadWriteOncePod"
      ],
      "default": "PERSISTENT_VOLUME_ACCESS_MODE_UNSPECIFIED",
      "description": "PersistentVolumeAccessMode are the ways the volume can be mounted.\n\n - PERSISTENT_VOLUME_ACCESS_MODE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - ReadWriteOnce: ReadWriteOnce can be mounted in read/write mode to exactly 1 host.\n - ReadOnlyMany: ReadOnlyMany can be mounted in read-only mode to many hosts.\n - ReadWriteMany: ReadWriteMany can be mounted in read/write mode to many hosts.\n - ReadWriteOncePod: ReadWriteOncePod can be mounted in read/write mode to exactly 1 pod.\nReadWriteOncePod cannot be used in combination with other access modes."
    },
    "v1alpha1PersistentVolumeClaim": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "spec": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeClaimSpec",
          "title": "PersistentVolumeClaimSpec describes the common attributes of storage devices\nand allows a Source for provider-specific attributes"
        },
        "status": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeClaimStatus",
          "title": "PersistentVolumeClaimStatus represents the status of PV claim"
        }
      },
      "description": "PersistentVolumeClaim represents a reference to a PersistentVolume in the same namespace."
    },
    "v1alpha1PersistentVolumeClaimCondition": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Type of this PersistentVolumeClaimCondition."
        },
        "status": {
          "type": "string",
          "description": "Status is the current status of PersistentVolumeClaim."
        },
        "lastProbeTime": {
          "type": "string",
          "format": "int64",
          "description": "Last time we probed the condition."
        },
        "lastTransitionTime": {
          "type": "string",
          "format": "int64",
          "description": "Last time the condition transitioned from one status to another."
        },
        "reason": {
          "type": "string",
          "description": "The reason of PersistentVolumeClaimCondition."
        },
        "message": {
          "type": "string",
          "description": "The message of PersistentVolumeClaimCondition."
        }
      },
      "description": "PersistentVolumeClaimConditionType defines the condition of PV claim."
    },
    "v1alpha1PersistentVolumeClaimSpec": {
      "type": "object",
      "properties": {
        "accessModes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1PersistentVolumeAccessMode"
          },
          "title": "Contains the types of access modes required\n+optional"
        },
        "selector": {
          "$ref": "#/definitions/typesLabelSelector",
          "title": "A label query over volumes to consider for binding. This selector is\nignored when VolumeName is set\n+optional"
        },
        "resources": {
          "$ref": "#/definitions/apicorev1alpha1ResourceRequirements",
          "description": "defined in pod.proto",
          "title": "Resources represents the minimum resources required\nIf RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements\nthat are lower than previous value but must still be higher than capacity recorded in the\nstatus field of the claim.\n+optional"
        },
        "volumeName": {
          "type": "string",
          "title": "VolumeName is the binding reference to the PersistentVolume backing this\nclaim. When set to non-empty value Selector is not evaluated\n+optional"
        },
        "storageClassName": {
          "type": "string",
          "title": "Name of the StorageClass required by the claim.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#class-1\n+optional"
        },
        "volumeMode": {
          "$ref": "#/definitions/PersistentVolumeClaimSpecVolumeMode",
          "title": "volumeMode defines what type of volume is required by the claim.\nValue of Filesystem is implied when not included in claim spec.\n+optional"
        },
        "dataSource": {
          "$ref": "#/definitions/v1alpha1TypedLocalObjectReference",
          "description": "TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace."
        },
        "dataSourceRef": {
          "$ref": "#/definitions/v1alpha1TypedObjectReference",
          "description": "dataSourceRef specifies the object from which to populate the volume with data, if a non-empty\nvolume is desired. This may be any object from a non-empty API group (non\ncore object) or a PersistentVolumeClaim object.\nWhen this field is specified, volume binding will only succeed if the type of\nthe specified object matches some installed volume populator or dynamic\nprovisioner.\nThis field will replace the functionality of the dataSource field and as such\nif both fields are non-empty, they must have the same value. For backwards\ncompatibility, when namespace isn't specified in dataSourceRef,\nboth fields (dataSource and dataSourceRef) will be set to the same\nvalue automatically if one of them is empty and the other is non-empty.\nWhen namespace is specified in dataSourceRef,\ndataSource isn't set to the same value and must be empty.\nThere are three important differences between dataSource and dataSourceRef:\n  - While dataSource only allows two specific types of objects, dataSourceRef\n    allows any non-core object, as well as PersistentVolumeClaim objects.\n  - While dataSource ignores disallowed values (dropping them), dataSourceRef\n    preserves all values, and generates an error if a disallowed value is\n    specified.\n  - While dataSource only allows local objects, dataSourceRef allows objects\n    in any namespaces.\n\n(Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\n(Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.\n+optional"
        },
        "supportExpansion": {
          "type": "boolean",
          "title": "The support expansion  represents this pvc weather support  expansion"
        },
        "supportSnapshot": {
          "type": "boolean",
          "title": "The support snapshot represents this pvc weather support snapshot"
        }
      },
      "title": "PersistentVolumeClaimSpec describes the common attributes of storage devices\nand allows a Source for provider-specific attributes"
    },
    "v1alpha1PersistentVolumeClaimStatus": {
      "type": "object",
      "properties": {
        "phase": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeClaimStatusPhase",
          "title": "Phase represents the current phase of PersistentVolumeClaim\n+optional"
        },
        "accessModes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1PersistentVolumeAccessMode"
          },
          "title": "AccessModes contains all ways the volume backing the PVC can be mounted\n+optional"
        },
        "capacity": {
          "$ref": "#/definitions/apicorev1alpha1ResourceList",
          "description": "defined in pod.proto",
          "title": "Represents the actual resources of the underlying volume\n+optional"
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1PersistentVolumeClaimCondition"
          },
          "title": "+optional"
        },
        "podName": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "PodName represents the pod to which the PVC belongs"
        },
        "snapshotCount": {
          "type": "integer",
          "format": "int32",
          "title": "snapshotCount represents how many snapshot the PVC has"
        }
      },
      "title": "PersistentVolumeClaimStatus represents the status of PV claim"
    },
    "v1alpha1PersistentVolumeClaimStatusPhase": {
      "type": "string",
      "enum": [
        "PHASE_UNSPECIFIED",
        "Pending",
        "Bound",
        "Lost"
      ],
      "default": "PHASE_UNSPECIFIED",
      "description": " - Pending: used for PersistentVolumeClaims that are not yet bound\n - Bound: used for PersistentVolumeClaims that are bound\n - Lost: used for PersistentVolumeClaims that lost their underlying\nPersistentVolume. The claim was bound to a PersistentVolume and this\nvolume does not exist any longer and all data on it was lost."
    },
    "v1alpha1PersistentVolumeClaimVolumeSource": {
      "type": "object",
      "properties": {
        "claimName": {
          "type": "string",
          "title": "ClaimName is the name of a PersistentVolumeClaim in the same namespace as\nthe pod using this volume. More info:\nhttps://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims"
        },
        "readOnly": {
          "type": "boolean",
          "title": "Will force the ReadOnly setting in VolumeMounts.\nDefault false.\n+optional"
        }
      },
      "description": "PersistentVolumeClaimVolumeSource references the user's PVC in the same\nnamespace. This volume finds the bound PV and mounts that volume for the pod.\nA PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another\ntype of volume that is owned by someone else (the system)."
    },
    "v1alpha1PersistentVolumeMode": {
      "type": "string",
      "enum": [
        "PERSISTENT_VOLUME_MODE_UNSPECIFIED",
        "Block",
        "Filesystem"
      ],
      "default": "PERSISTENT_VOLUME_MODE_UNSPECIFIED",
      "description": "PersistentVolumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state.\n\n - PERSISTENT_VOLUME_MODE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - Block: Block means the volume will not be formatted with a filesystem and will remain a raw block device.\n - Filesystem: Filesystem means the volume will be or is formatted with a filesystem."
    },
    "v1alpha1PersistentVolumeReclaimPolicy": {
      "type": "string",
      "enum": [
        "PERSISTENT_VOLUME_RECLAIM_POLICY_UNSPECIFIED",
        "Recycle",
        "Delete",
        "Retain"
      ],
      "default": "PERSISTENT_VOLUME_RECLAIM_POLICY_UNSPECIFIED",
      "description": "PersistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.\n\n - PERSISTENT_VOLUME_RECLAIM_POLICY_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - Recycle: Recycle means the volume will be recycled back into the pool of unbound persistent volumes on release from its claim.\nThe volume plugin must support Recycling.\n - Delete: Delete means the volume will be deleted from Kubernetes on release from its claim.\nThe volume plugin must support Deletion.\n - Retain: Retain means the volume will be left in its current phase (Released) for manual reclamation by the administrator.\nThe default policy is Retain."
    },
    "v1alpha1PersistentVolumeSource": {
      "type": "object",
      "properties": {
        "hostPath": {
          "$ref": "#/definitions/apicorev1alpha1HostPathVolumeSource"
        },
        "nfs": {
          "$ref": "#/definitions/v1alpha1NFSVolumeSource"
        },
        "local": {
          "$ref": "#/definitions/v1alpha1LocalVolumeSource"
        }
      }
    },
    "v1alpha1PersistentVolumeSpec": {
      "type": "object",
      "properties": {
        "capacity": {
          "type": "string",
          "description": "Capacity is the description of the persistent volume's resources and capacity."
        },
        "accessModes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1alpha1PersistentVolumeAccessMode"
          },
          "description": "AccessModes contains all ways the volume can be mounted."
        },
        "persistentVolumeReclaimPolicy": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeReclaimPolicy",
          "description": "PersistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.\nValid options are Retain (default for manually created PersistentVolumes), Delete (default\nfor dynamically provisioned PersistentVolumes), and Recycle (deprecated).\nRecycle must be supported by the volume plugin underlying this PersistentVolume."
        },
        "mountOptions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "MountOptions is the list of mount options, e.g. [\"ro\", \"soft\"]. Not validated - mount will\nsimply fail if one is invalid."
        },
        "volumeMode": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeMode",
          "description": "VolumeMode defines if a volume is intended to be used with a formatted filesystem\nor to remain in raw block state. Value of Filesystem is implied when not included in spec."
        },
        "persistentVolumeSource": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeSource"
        },
        "storageClassName": {
          "type": "string"
        }
      },
      "description": "PersistentVolumeSpec is the specification of a persistent volume."
    },
    "v1alpha1PersistentVolumeStatus": {
      "type": "object",
      "properties": {
        "phase": {
          "$ref": "#/definitions/corev1alpha1Phase",
          "title": "Phase indicates if a volume is available, bound to a claim, or released by a claim\n+optional"
        },
        "message": {
          "type": "string",
          "title": "A human-readable message indicating details about why the volume is in this state.\n+optional"
        },
        "reason": {
          "type": "string",
          "title": "Reason is a brief CamelCase string that describes any failure and is meant for machine parsing and tidy display in the CLI\n+optional"
        }
      }
    },
    "v1alpha1PlatformSummury": {
      "type": "object",
      "properties": {
        "clusterNum": {
          "type": "integer",
          "format": "int32"
        },
        "nodeNum": {
          "type": "integer",
          "format": "int32"
        },
        "acceleratorCardNum": {
          "type": "integer",
          "format": "int32"
        },
        "kantaloupeflowNum": {
          "type": "integer",
          "format": "int32"
        },
        "acceleratorCardSummury": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1AcceleraorCardSummuray"
          }
        }
      }
    },
    "v1alpha1PluginType": {
      "type": "string",
      "enum": [
        "PLUGIN_TYPE_UNSPECIFIED",
        "ssh",
        "vscode",
        "jupyter"
      ],
      "default": "PLUGIN_TYPE_UNSPECIFIED",
      "description": " - PLUGIN_TYPE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return."
    },
    "v1alpha1PodSpec": {
      "type": "object",
      "properties": {
        "volumes": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Volume"
          },
          "title": "List of volumes that can be mounted by containers belonging to the pod.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes\n+optional"
        },
        "containers": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1Container"
          },
          "description": "Containers name."
        }
      },
      "description": "PodSpec describes the attributes that a pod is created with."
    },
    "v1alpha1PodTemplateSpec": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "spec": {
          "$ref": "#/definitions/v1alpha1PodSpec",
          "description": "Spec describes the attributes that a pod is created with."
        }
      },
      "description": "template is the object that describes the pod that will be created if\ninsufficient replicas are detected. Each pod stamped out by the StatefulSet\nwill fulfill this Template, but have a unique identity from the rest\nof the StatefulSet."
    },
    "v1alpha1Ports": {
      "type": "object",
      "properties": {
        "containerPort": {
          "type": "integer",
          "format": "int32",
          "description": "ContainerPort connects to a certain container port in a pod."
        },
        "hostPort": {
          "type": "integer",
          "format": "int32",
          "title": "Number of port to expose on the host.\nIf specified, this must be a valid port number, 0 \u003c x \u003c 65536.\nIf HostNetwork is specified, this must match ContainerPort.\nMost containers do not need this.\n+optional"
        },
        "name": {
          "type": "string",
          "title": "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each\nnamed port in a pod must have a unique name. Name for the port that can be\nreferred to by services.\n+optional"
        },
        "protocol": {
          "type": "string",
          "title": "Protocol for port. Must be UDP, TCP, or SCTP.\nDefaults to \"TCP\".\n+optional\n+default=\"TCP\""
        }
      },
      "title": "Ports are not allowed for ephemeral containers.\n+optional\n+patchMergeKey=containerPort\n+patchStrategy=merge\n+listType=map\n+listMapKey=containerPort\n+listMapKey=protocol"
    },
    "v1alpha1QuotaResponse": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the quota name."
        },
        "namespace": {
          "type": "string",
          "description": "Namespace where the quota is located."
        },
        "createdTime": {
          "type": "string",
          "format": "int64",
          "description": "CreatedTime is the creation timestamp."
        },
        "hard": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Hard contains resource names and their maximum allowed values."
        },
        "used": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Used shows the current consumption of the quota."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels attached to the quota."
        }
      },
      "description": "QuotaResponse represents a quota response."
    },
    "v1alpha1RankingType": {
      "type": "string",
      "enum": [
        "RANKING_TYPE_UNSPECIFIED",
        "RANKING_TYPE_ALLOCATED",
        "RANKING_TYPE_USED"
      ],
      "default": "RANKING_TYPE_UNSPECIFIED",
      "title": "RankingType represents the type of ranking metric (allocated or used)"
    },
    "v1alpha1ResourceSummary": {
      "type": "object",
      "properties": {
        "totalNum": {
          "type": "integer",
          "format": "int32",
          "description": "Refers to a resource totally."
        },
        "readyNum": {
          "type": "integer",
          "format": "int32",
          "description": "Refers to a resource has been ready."
        }
      },
      "description": "ResourceSummary refers to a resource totally."
    },
    "v1alpha1ResourceTrendResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1TimeSeries"
          },
          "title": "The time series data"
        }
      },
      "title": "ResourceTrendResponse represents the response containing resource trend data"
    },
    "v1alpha1ResourceType": {
      "type": "string",
      "enum": [
        "RESOURCE_TYPE_UNSPECIFIED",
        "RESOURCE_TYPE_CPU",
        "RESOURCE_TYPE_MEMORY",
        "RESOURCE_TYPE_GPU_CORE",
        "RESOURCE_TYPE_GPU_MEMORY",
        "RESOURCE_TYPE_STORAGE",
        "RESOURCE_TYPE_NETWORK"
      ],
      "default": "RESOURCE_TYPE_UNSPECIFIED",
      "title": "ResourceType represents the type of resource being queried"
    },
    "v1alpha1Secret": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "immutable": {
          "type": "boolean",
          "title": "Immutable, if set to true, ensures that data stored in the Secret cannot\nbe updated (only object metadata can be modified).\nIf not set to true, the field can be modified at any time.\nDefaulted to nil.\n+optional"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Data contains the secret data. Each key must consist of alphanumeric\ncharacters, '-', '_' or '.'. The serialized form of the secret data is a\nbase64 encoded string, representing the arbitrary (possibly non-string)\ndata value here. Described in https://tools.ietf.org/html/rfc4648#section-4\n+optional"
        },
        "stringData": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "stringData allows specifying non-binary secret data in string form.\nIt is provided as a write-only input field for convenience.\nAll keys and values are merged into the data field on write, overwriting any existing values.\nThe stringData field is never output when reading from the API.\n+k8s:conversion-gen=false\n+optional"
        },
        "type": {
          "type": "string",
          "title": "Used to facilitate programmatic handling of secret data.\n+optional"
        }
      }
    },
    "v1alpha1SecretVolumeSource": {
      "type": "object",
      "properties": {
        "secretName": {
          "type": "string",
          "title": "Name of the secret in the pod's namespace to use.\nMore info: https://kubernetes.io/docs/concepts/storage/volumes#secret\n+optional"
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1KeyToPath"
          },
          "title": "If unspecified, each key-value pair in the Data field of the referenced\nSecret will be projected into the volume as a file whose name is the\nkey and content is the value. If specified, the listed keys will be\nprojected into the specified paths, and unlisted keys will not be\npresent. If a key is specified which is not present in the Secret,\nthe volume setup will error unless it is marked optional. Paths must be\nrelative and may not contain the '..' path or start with '..'.\n+optional"
        },
        "defaultMode": {
          "type": "integer",
          "format": "int32",
          "title": "Optional: mode bits used to set permissions on created files by default.\nMust be an octal value between 0000 and 0777 or a decimal value between 0\nand 511. YAML accepts both octal and decimal values, JSON requires decimal\nvalues for mode bits. Defaults to 0644. Directories within the path are not\naffected by this setting. This might be in conflict with other options that\naffect the file mode, like fsGroup, and the result can be other mode bits\nset. +optional"
        },
        "optional": {
          "type": "boolean",
          "title": "Specify whether the Secret or its keys must be defined\n+optional"
        }
      },
      "description": "Adapts a Secret into a volume.\nThe contents of the target Secret's Data field will be presented in a volume\nas files using the keys in the Data field as the file names.\nSecret volumes support ownership management and SELinux relabeling."
    },
    "v1alpha1Storage": {
      "type": "object",
      "properties": {
        "persistentVolumeClaim": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeClaim",
          "description": "Spec defines a specification of a persistent volume owned by the cluster."
        },
        "storageType": {
          "$ref": "#/definitions/v1alpha1StorageType"
        }
      }
    },
    "v1alpha1StorageClass": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/typesObjectMeta",
          "description": "Standard object's metadata."
        },
        "provisioner": {
          "type": "string",
          "description": "Provisioner indicates the type of the provisioner."
        },
        "reclaimPolicy": {
          "$ref": "#/definitions/StorageClassReclaimPolicy",
          "title": "persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.\nValid options are Retain (default for manually created PersistentVolumes), Delete (default\nfor dynamically provisioned PersistentVolumes), and Recycle (deprecated).\nRecycle must be supported by the volume plugin underlying this PersistentVolume.\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming\n+optional"
        },
        "storageClassName": {
          "type": "string",
          "title": "storageClassName is the name of StorageClass to which this persistent volume belongs. Empty value\nmeans that this volume does not belong to any StorageClass.\n+optional"
        },
        "volumeBindingMode": {
          "$ref": "#/definitions/StorageClassVolumeBindingMode",
          "title": "VolumeBindingMode indicates how PersistentVolumeClaims should be\nprovisioned and bound.  When unset, VolumeBindingImmediate is used.\nThis field is only honored by servers that enable the VolumeScheduling feature.\n+optional"
        },
        "mountOptions": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Dynamically provisioned PersistentVolumes of this storage class are\ncreated with these mountOptions, e.g. [\"ro\", \"soft\"]. Not validated -\nmount of the PVs will simply fail if one is invalid.\n+optional"
        },
        "parameters": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Parameters holds the parameters for the provisioner that should\ncreate volumes of this storage class.\n+optional"
        },
        "allowVolumeExpansion": {
          "type": "boolean",
          "title": "AllowVolumeExpansion shows whether the storage class allow volume expand\n+optional"
        }
      },
      "description": "StorageClass describes the parameters for a class of storage for\nwhich PersistentVolumes can be dynamically provisioned.\n\nStorageClasses are non-namespaced; the name of the storage class\naccording to etcd is in ObjectMeta.Name."
    },
    "v1alpha1StorageType": {
      "type": "string",
      "enum": [
        "StorageTypeUnspecified",
        "LocalPV",
        "NFS",
        "Dynamic"
      ],
      "default": "StorageTypeUnspecified"
    },
    "v1alpha1Taint": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "Required. The taint key to be applied to a node."
        },
        "value": {
          "type": "string",
          "description": "The taint value corresponding to the taint key."
        },
        "effect": {
          "$ref": "#/definitions/v1alpha1TaintEffect",
          "description": "Valid effects are NoSchedule, PreferNoSchedule, and NoExecute."
        }
      }
    },
    "v1alpha1TaintEffect": {
      "type": "string",
      "enum": [
        "TAINT_EFFECT_UNSPECIFIED",
        "NoSchedule",
        "PreferNoSchedule",
        "NoExecute"
      ],
      "default": "TAINT_EFFECT_UNSPECIFIED",
      "description": "Valid effects are NoSchedule, PreferNoSchedule, and NoExecute.\n\n - TAINT_EFFECT_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return.\n - NoSchedule: NoSchedule tries to avoid scheduling pods to nodes where they can't\ntolerate taints.\n - PreferNoSchedule: This is not mandatory tries to avoid scheduling pods to nodes.\n - NoExecute: NoExecute is not assign pod  to or evicted pod from the node."
    },
    "v1alpha1TimeSeries": {
      "type": "object",
      "properties": {
        "metric": {
          "type": "string",
          "title": "The metric name (e.g. \"allocated\", \"used\")"
        },
        "points": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1TimeSeriesPoint"
          },
          "title": "The data points in this series"
        }
      },
      "title": "TimeSeries represents a series of data points"
    },
    "v1alpha1TimeSeriesPoint": {
      "type": "object",
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp in seconds since epoch"
        },
        "value": {
          "type": "number",
          "format": "double",
          "title": "The value at this timestamp"
        }
      },
      "title": "TimeSeriesPoint represents a single point in a time series"
    },
    "v1alpha1TopNodeResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1DistributionPoint"
          }
        }
      },
      "title": "TopNodeResponse represents the response containing top K nodes"
    },
    "v1alpha1TypedLocalObjectReference": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "type": "string",
          "description": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required."
        },
        "kind": {
          "type": "string",
          "description": "Kind is the type of resource being referenced."
        },
        "name": {
          "type": "string",
          "description": "Name is the name of resource being referenced."
        }
      },
      "description": "TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace."
    },
    "v1alpha1TypedObjectReference": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "type": "string",
          "title": "APIGroup is the group for the resource being referenced.\nIf APIGroup is not specified, the specified Kind must be in the core API group.\nFor any other third-party types, APIGroup is required.\n+optional"
        },
        "kind": {
          "type": "string",
          "title": "Kind is the type of resource being referenced"
        },
        "name": {
          "type": "string",
          "title": "Name is the name of resource being referenced"
        },
        "namespace": {
          "type": "string",
          "title": "Namespace is the namespace of resource being referenced\nNote that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.\n(Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.\n+featureGate=CrossNamespaceVolumeDataSource\n+optional"
        }
      }
    },
    "v1alpha1UpdateConfigMapResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "title": "The data is the ConfigMap YAML details"
        }
      }
    },
    "v1alpha1UpdatePersistentVolumeResponse": {
      "type": "object",
      "properties": {
        "data": {
          "$ref": "#/definitions/v1alpha1PersistentVolume",
          "description": "Data is the PersistentVolume YAML details."
        }
      },
      "description": "UpdatePersistentVolumeResponse returns the created PersistentVolume data information."
    },
    "v1alpha1ValidateKubeconfigRequest": {
      "type": "object",
      "properties": {
        "kubeconfig": {
          "type": "string",
          "description": "kubeconfig is the str of kube config."
        }
      },
      "description": "ValidateKubeconfigRequest defines a request for validating whether the kubeconfig is valid."
    },
    "v1alpha1ValidateKubeconfigResponse": {
      "type": "object",
      "properties": {
        "validate": {
          "type": "boolean",
          "description": "validate represent whether the config is valid."
        }
      },
      "description": "ValidateKubeconfigResponse defines a response to return the validate result."
    },
    "v1alpha1Volume": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "hostPath": {
          "$ref": "#/definitions/apikantaloupeflowv1alpha1HostPathVolumeSource",
          "description": "HostPathVolumeSource represents a host path mapped into a pod.\nHost path volumes do not support ownership management or SELinux\nrelabeling."
        },
        "emptyDir": {
          "$ref": "#/definitions/v1alpha1EmptyDirVolumeSource",
          "description": "EmptyDirVolumeSource represents an empty directory for a pod.\nEmpty directory volumes support ownership management and SELinux\nrelabeling."
        },
        "secret": {
          "$ref": "#/definitions/v1alpha1SecretVolumeSource",
          "description": "SecretVolumeSource adapts a Secret into a volume.\nThe contents of the target Secret's Data field will be presented in a\nvolume as files using the keys in the Data field as the file names. Secret\nvolumes support ownership management and SELinux relabeling."
        },
        "persistentVolumeClaim": {
          "$ref": "#/definitions/v1alpha1PersistentVolumeClaimVolumeSource",
          "title": "PersistentVolumeClaimVolumeSource represents a reference to a\nPersistentVolumeClaim in the same namespace"
        },
        "configMap": {
          "$ref": "#/definitions/v1alpha1ConfigMapVolumeSource",
          "description": "ConfigMapVolumeSource adapts a ConfigMap into a volume.\n\nThe contents of the target ConfigMap's Data field will be presented in a\nvolume as files using the keys in the Data field as the file names, unless\nthe items element is populated with specific mappings of keys to paths.\nConfigMap volumes support ownership management and SELinux relabeling."
        }
      },
      "description": "Volume represents a named volume in a pod that may be accessed by any\ncontainer in the pod."
    },
    "v1alpha1VolumeMount": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "This must match the Name of a Volume."
        },
        "readOnly": {
          "type": "boolean",
          "title": "Mounted read-only if true, read-write otherwise (false or unspecified).\nDefaults to false.\n+optional"
        },
        "mountPath": {
          "type": "string",
          "description": "Full path to the mount volume path."
        },
        "subPath": {
          "type": "string",
          "title": "Path within the volume from which the container's volume should be mounted.\nDefaults to \"\" (volume's root).\n+optional"
        },
        "mountPropagation": {
          "type": "string",
          "title": "mountPropagation determines how mounts are propagated from the host\nto container and the other way around.\nWhen not set, MountPropagationNone is used.\nThis field is beta in 1.10.\n+optional"
        },
        "subPathExpr": {
          "type": "string",
          "title": "Expanded path within the volume from which the container's volume should be\nmounted. Behaves similarly to SubPath but environment variable references\n$(VAR_NAME) are expanded using the container's environment. Defaults to \"\"\n(volume's root). SubPathExpr and SubPath are mutually exclusive. +optional"
        }
      },
      "description": "VolumeMount for this container."
    },
    "v1alpha1WorkloadDistributionResponse": {
      "type": "object",
      "properties": {
        "data": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1alpha1DistributionPoint"
          },
          "title": "The distribution data points"
        }
      },
      "title": "WorkloadDistributionResponse represents the response for workload distribution"
    },
    "v1alpha1WorkloadType": {
      "type": "string",
      "enum": [
        "WORKLOAD_TYPE_UNSPECIFIED",
        "Pod",
        "Deployment"
      ],
      "default": "WORKLOAD_TYPE_UNSPECIFIED",
      "description": " - WORKLOAD_TYPE_UNSPECIFIED: This is only a meaningless placeholder, to avoid zero not return."
    }
  }
}
