// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: api/v1/kantaloupe.proto

package v1

import (
	context "context"
	v1alpha17 "github.com/dynamia-ai/kantaloupe/api/acceleratorcard/v1alpha1"
	v1alpha1 "github.com/dynamia-ai/kantaloupe/api/clusters/v1alpha1"
	v1alpha12 "github.com/dynamia-ai/kantaloupe/api/core/v1alpha1"
	v1alpha14 "github.com/dynamia-ai/kantaloupe/api/credentials/v1alpha1"
	v1alpha13 "github.com/dynamia-ai/kantaloupe/api/kantaloupeflow/v1alpha1"
	v1alpha11 "github.com/dynamia-ai/kantaloupe/api/monitoring/v1alpha1"
	v1alpha15 "github.com/dynamia-ai/kantaloupe/api/quotas/v1alpha1"
	v1alpha16 "github.com/dynamia-ai/kantaloupe/api/storage/v1alpha1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Cluster_ListClusters_FullMethodName              = "/kantaloupev1.Cluster/ListClusters"
	Cluster_IntegrateCluster_FullMethodName          = "/kantaloupev1.Cluster/IntegrateCluster"
	Cluster_GetCluster_FullMethodName                = "/kantaloupev1.Cluster/GetCluster"
	Cluster_UpdateCluster_FullMethodName             = "/kantaloupev1.Cluster/UpdateCluster"
	Cluster_DeleteCluster_FullMethodName             = "/kantaloupev1.Cluster/DeleteCluster"
	Cluster_ValidateKubeconfig_FullMethodName        = "/kantaloupev1.Cluster/ValidateKubeconfig"
	Cluster_GetPlatformSummury_FullMethodName        = "/kantaloupev1.Cluster/GetPlatformSummury"
	Cluster_ListClusterVersions_FullMethodName       = "/kantaloupev1.Cluster/ListClusterVersions"
	Cluster_GetPlatformResourceTrend_FullMethodName  = "/kantaloupev1.Cluster/GetPlatformResourceTrend"
	Cluster_GetPlatformGPUTop_FullMethodName         = "/kantaloupev1.Cluster/GetPlatformGPUTop"
	Cluster_GetClusterPlugins_FullMethodName         = "/kantaloupev1.Cluster/GetClusterPlugins"
	Cluster_GetClusterCardRequestType_FullMethodName = "/kantaloupev1.Cluster/GetClusterCardRequestType"
)

// ClusterClient is the client API for Cluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClusterClient interface {
	// ListClusters lists cluster proto resources.
	ListClusters(ctx context.Context, in *v1alpha1.ListClustersRequest, opts ...grpc.CallOption) (*v1alpha1.ListClustersResponse, error)
	// IntegrateCluster integrates a cluster.
	IntegrateCluster(ctx context.Context, in *v1alpha1.IntegrateClusterRequest, opts ...grpc.CallOption) (*v1alpha1.Cluster, error)
	// GetCluster gets the details of the specified cluster.
	GetCluster(ctx context.Context, in *v1alpha1.GetClusterRequest, opts ...grpc.CallOption) (*v1alpha1.Cluster, error)
	// UpdateCluster updates the specified cluster.
	UpdateCluster(ctx context.Context, in *v1alpha1.UpdateClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteCluster deletes the specified cluster.
	DeleteCluster(ctx context.Context, in *v1alpha1.DeleteClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ValidateKubeconfig validats whether the config is valid.
	ValidateKubeconfig(ctx context.Context, in *v1alpha1.ValidateKubeconfigRequest, opts ...grpc.CallOption) (*v1alpha1.ValidateKubeconfigResponse, error)
	// GetPlatformSummury gets platform summury.
	GetPlatformSummury(ctx context.Context, in *v1alpha1.GetPlatformSummuryRequest, opts ...grpc.CallOption) (*v1alpha1.PlatformSummury, error)
	// ListClusterVersions lists cluster versions.
	ListClusterVersions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*v1alpha1.ListClusterVersionsResponse, error)
	GetPlatformResourceTrend(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error)
	GetPlatformGPUTop(ctx context.Context, in *v1alpha1.GetPlatformGPUTopRequest, opts ...grpc.CallOption) (*v1alpha1.GetPlatformGPUTopResponse, error)
	GetClusterPlugins(ctx context.Context, in *v1alpha1.GetClusterPluginsRequest, opts ...grpc.CallOption) (*v1alpha1.GetClusterPluginsResponse, error)
	GetClusterCardRequestType(ctx context.Context, in *v1alpha1.GetClusterCardRequestTypeRequest, opts ...grpc.CallOption) (*v1alpha1.GetClusterCardRequestTypeResponse, error)
}

type clusterClient struct {
	cc grpc.ClientConnInterface
}

func NewClusterClient(cc grpc.ClientConnInterface) ClusterClient {
	return &clusterClient{cc}
}

func (c *clusterClient) ListClusters(ctx context.Context, in *v1alpha1.ListClustersRequest, opts ...grpc.CallOption) (*v1alpha1.ListClustersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.ListClustersResponse)
	err := c.cc.Invoke(ctx, Cluster_ListClusters_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) IntegrateCluster(ctx context.Context, in *v1alpha1.IntegrateClusterRequest, opts ...grpc.CallOption) (*v1alpha1.Cluster, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.Cluster)
	err := c.cc.Invoke(ctx, Cluster_IntegrateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetCluster(ctx context.Context, in *v1alpha1.GetClusterRequest, opts ...grpc.CallOption) (*v1alpha1.Cluster, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.Cluster)
	err := c.cc.Invoke(ctx, Cluster_GetCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) UpdateCluster(ctx context.Context, in *v1alpha1.UpdateClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Cluster_UpdateCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) DeleteCluster(ctx context.Context, in *v1alpha1.DeleteClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Cluster_DeleteCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) ValidateKubeconfig(ctx context.Context, in *v1alpha1.ValidateKubeconfigRequest, opts ...grpc.CallOption) (*v1alpha1.ValidateKubeconfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.ValidateKubeconfigResponse)
	err := c.cc.Invoke(ctx, Cluster_ValidateKubeconfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetPlatformSummury(ctx context.Context, in *v1alpha1.GetPlatformSummuryRequest, opts ...grpc.CallOption) (*v1alpha1.PlatformSummury, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.PlatformSummury)
	err := c.cc.Invoke(ctx, Cluster_GetPlatformSummury_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) ListClusterVersions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*v1alpha1.ListClusterVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.ListClusterVersionsResponse)
	err := c.cc.Invoke(ctx, Cluster_ListClusterVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetPlatformResourceTrend(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.ResourceTrendResponse)
	err := c.cc.Invoke(ctx, Cluster_GetPlatformResourceTrend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetPlatformGPUTop(ctx context.Context, in *v1alpha1.GetPlatformGPUTopRequest, opts ...grpc.CallOption) (*v1alpha1.GetPlatformGPUTopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.GetPlatformGPUTopResponse)
	err := c.cc.Invoke(ctx, Cluster_GetPlatformGPUTop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetClusterPlugins(ctx context.Context, in *v1alpha1.GetClusterPluginsRequest, opts ...grpc.CallOption) (*v1alpha1.GetClusterPluginsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.GetClusterPluginsResponse)
	err := c.cc.Invoke(ctx, Cluster_GetClusterPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetClusterCardRequestType(ctx context.Context, in *v1alpha1.GetClusterCardRequestTypeRequest, opts ...grpc.CallOption) (*v1alpha1.GetClusterCardRequestTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha1.GetClusterCardRequestTypeResponse)
	err := c.cc.Invoke(ctx, Cluster_GetClusterCardRequestType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterServer is the server API for Cluster service.
// All implementations must embed UnimplementedClusterServer
// for forward compatibility.
type ClusterServer interface {
	// ListClusters lists cluster proto resources.
	ListClusters(context.Context, *v1alpha1.ListClustersRequest) (*v1alpha1.ListClustersResponse, error)
	// IntegrateCluster integrates a cluster.
	IntegrateCluster(context.Context, *v1alpha1.IntegrateClusterRequest) (*v1alpha1.Cluster, error)
	// GetCluster gets the details of the specified cluster.
	GetCluster(context.Context, *v1alpha1.GetClusterRequest) (*v1alpha1.Cluster, error)
	// UpdateCluster updates the specified cluster.
	UpdateCluster(context.Context, *v1alpha1.UpdateClusterRequest) (*emptypb.Empty, error)
	// DeleteCluster deletes the specified cluster.
	DeleteCluster(context.Context, *v1alpha1.DeleteClusterRequest) (*emptypb.Empty, error)
	// ValidateKubeconfig validats whether the config is valid.
	ValidateKubeconfig(context.Context, *v1alpha1.ValidateKubeconfigRequest) (*v1alpha1.ValidateKubeconfigResponse, error)
	// GetPlatformSummury gets platform summury.
	GetPlatformSummury(context.Context, *v1alpha1.GetPlatformSummuryRequest) (*v1alpha1.PlatformSummury, error)
	// ListClusterVersions lists cluster versions.
	ListClusterVersions(context.Context, *emptypb.Empty) (*v1alpha1.ListClusterVersionsResponse, error)
	GetPlatformResourceTrend(context.Context, *emptypb.Empty) (*v1alpha11.ResourceTrendResponse, error)
	GetPlatformGPUTop(context.Context, *v1alpha1.GetPlatformGPUTopRequest) (*v1alpha1.GetPlatformGPUTopResponse, error)
	GetClusterPlugins(context.Context, *v1alpha1.GetClusterPluginsRequest) (*v1alpha1.GetClusterPluginsResponse, error)
	GetClusterCardRequestType(context.Context, *v1alpha1.GetClusterCardRequestTypeRequest) (*v1alpha1.GetClusterCardRequestTypeResponse, error)
	mustEmbedUnimplementedClusterServer()
}

// UnimplementedClusterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedClusterServer struct{}

func (UnimplementedClusterServer) ListClusters(context.Context, *v1alpha1.ListClustersRequest) (*v1alpha1.ListClustersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClusters not implemented")
}
func (UnimplementedClusterServer) IntegrateCluster(context.Context, *v1alpha1.IntegrateClusterRequest) (*v1alpha1.Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntegrateCluster not implemented")
}
func (UnimplementedClusterServer) GetCluster(context.Context, *v1alpha1.GetClusterRequest) (*v1alpha1.Cluster, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCluster not implemented")
}
func (UnimplementedClusterServer) UpdateCluster(context.Context, *v1alpha1.UpdateClusterRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCluster not implemented")
}
func (UnimplementedClusterServer) DeleteCluster(context.Context, *v1alpha1.DeleteClusterRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCluster not implemented")
}
func (UnimplementedClusterServer) ValidateKubeconfig(context.Context, *v1alpha1.ValidateKubeconfigRequest) (*v1alpha1.ValidateKubeconfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateKubeconfig not implemented")
}
func (UnimplementedClusterServer) GetPlatformSummury(context.Context, *v1alpha1.GetPlatformSummuryRequest) (*v1alpha1.PlatformSummury, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlatformSummury not implemented")
}
func (UnimplementedClusterServer) ListClusterVersions(context.Context, *emptypb.Empty) (*v1alpha1.ListClusterVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClusterVersions not implemented")
}
func (UnimplementedClusterServer) GetPlatformResourceTrend(context.Context, *emptypb.Empty) (*v1alpha11.ResourceTrendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlatformResourceTrend not implemented")
}
func (UnimplementedClusterServer) GetPlatformGPUTop(context.Context, *v1alpha1.GetPlatformGPUTopRequest) (*v1alpha1.GetPlatformGPUTopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlatformGPUTop not implemented")
}
func (UnimplementedClusterServer) GetClusterPlugins(context.Context, *v1alpha1.GetClusterPluginsRequest) (*v1alpha1.GetClusterPluginsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterPlugins not implemented")
}
func (UnimplementedClusterServer) GetClusterCardRequestType(context.Context, *v1alpha1.GetClusterCardRequestTypeRequest) (*v1alpha1.GetClusterCardRequestTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterCardRequestType not implemented")
}
func (UnimplementedClusterServer) mustEmbedUnimplementedClusterServer() {}
func (UnimplementedClusterServer) testEmbeddedByValue()                 {}

// UnsafeClusterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClusterServer will
// result in compilation errors.
type UnsafeClusterServer interface {
	mustEmbedUnimplementedClusterServer()
}

func RegisterClusterServer(s grpc.ServiceRegistrar, srv ClusterServer) {
	// If the following call pancis, it indicates UnimplementedClusterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Cluster_ServiceDesc, srv)
}

func _Cluster_ListClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.ListClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).ListClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_ListClusters_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).ListClusters(ctx, req.(*v1alpha1.ListClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_IntegrateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.IntegrateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).IntegrateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_IntegrateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).IntegrateCluster(ctx, req.(*v1alpha1.IntegrateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.GetClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_GetCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetCluster(ctx, req.(*v1alpha1.GetClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_UpdateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.UpdateClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).UpdateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_UpdateCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).UpdateCluster(ctx, req.(*v1alpha1.UpdateClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.DeleteClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_DeleteCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).DeleteCluster(ctx, req.(*v1alpha1.DeleteClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_ValidateKubeconfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.ValidateKubeconfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).ValidateKubeconfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_ValidateKubeconfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).ValidateKubeconfig(ctx, req.(*v1alpha1.ValidateKubeconfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetPlatformSummury_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.GetPlatformSummuryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetPlatformSummury(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_GetPlatformSummury_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetPlatformSummury(ctx, req.(*v1alpha1.GetPlatformSummuryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_ListClusterVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).ListClusterVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_ListClusterVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).ListClusterVersions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetPlatformResourceTrend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetPlatformResourceTrend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_GetPlatformResourceTrend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetPlatformResourceTrend(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetPlatformGPUTop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.GetPlatformGPUTopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetPlatformGPUTop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_GetPlatformGPUTop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetPlatformGPUTop(ctx, req.(*v1alpha1.GetPlatformGPUTopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetClusterPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.GetClusterPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetClusterPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_GetClusterPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetClusterPlugins(ctx, req.(*v1alpha1.GetClusterPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetClusterCardRequestType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha1.GetClusterCardRequestTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetClusterCardRequestType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Cluster_GetClusterCardRequestType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetClusterCardRequestType(ctx, req.(*v1alpha1.GetClusterCardRequestTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Cluster_ServiceDesc is the grpc.ServiceDesc for Cluster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Cluster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.Cluster",
	HandlerType: (*ClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListClusters",
			Handler:    _Cluster_ListClusters_Handler,
		},
		{
			MethodName: "IntegrateCluster",
			Handler:    _Cluster_IntegrateCluster_Handler,
		},
		{
			MethodName: "GetCluster",
			Handler:    _Cluster_GetCluster_Handler,
		},
		{
			MethodName: "UpdateCluster",
			Handler:    _Cluster_UpdateCluster_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _Cluster_DeleteCluster_Handler,
		},
		{
			MethodName: "ValidateKubeconfig",
			Handler:    _Cluster_ValidateKubeconfig_Handler,
		},
		{
			MethodName: "GetPlatformSummury",
			Handler:    _Cluster_GetPlatformSummury_Handler,
		},
		{
			MethodName: "ListClusterVersions",
			Handler:    _Cluster_ListClusterVersions_Handler,
		},
		{
			MethodName: "GetPlatformResourceTrend",
			Handler:    _Cluster_GetPlatformResourceTrend_Handler,
		},
		{
			MethodName: "GetPlatformGPUTop",
			Handler:    _Cluster_GetPlatformGPUTop_Handler,
		},
		{
			MethodName: "GetClusterPlugins",
			Handler:    _Cluster_GetClusterPlugins_Handler,
		},
		{
			MethodName: "GetClusterCardRequestType",
			Handler:    _Cluster_GetClusterCardRequestType_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}

const (
	Core_ListPersistentVolumes_FullMethodName   = "/kantaloupev1.Core/ListPersistentVolumes"
	Core_GetPersistentVolume_FullMethodName     = "/kantaloupev1.Core/GetPersistentVolume"
	Core_GetPersistentVolumeJSON_FullMethodName = "/kantaloupev1.Core/GetPersistentVolumeJSON"
	Core_CreatePersistentVolume_FullMethodName  = "/kantaloupev1.Core/CreatePersistentVolume"
	Core_UpdatePersistentVolume_FullMethodName  = "/kantaloupev1.Core/UpdatePersistentVolume"
	Core_DeletePersistentVolume_FullMethodName  = "/kantaloupev1.Core/DeletePersistentVolume"
	Core_DeleteSecret_FullMethodName            = "/kantaloupev1.Core/DeleteSecret"
	Core_GetSecret_FullMethodName               = "/kantaloupev1.Core/GetSecret"
	Core_ListSecrets_FullMethodName             = "/kantaloupev1.Core/ListSecrets"
	Core_CreateSecret_FullMethodName            = "/kantaloupev1.Core/CreateSecret"
	Core_ListClusterNamespaces_FullMethodName   = "/kantaloupev1.Core/ListClusterNamespaces"
	Core_ListClusterGPUSummary_FullMethodName   = "/kantaloupev1.Core/ListClusterGPUSummary"
	Core_ListClusterEvents_FullMethodName       = "/kantaloupev1.Core/ListClusterEvents"
	Core_ListEvents_FullMethodName              = "/kantaloupev1.Core/ListEvents"
	Core_ListNodes_FullMethodName               = "/kantaloupev1.Core/ListNodes"
	Core_GetNode_FullMethodName                 = "/kantaloupev1.Core/GetNode"
	Core_PutNodeLabels_FullMethodName           = "/kantaloupev1.Core/PutNodeLabels"
	Core_PutNodeTaints_FullMethodName           = "/kantaloupev1.Core/PutNodeTaints"
	Core_UpdateNodeAnnotations_FullMethodName   = "/kantaloupev1.Core/UpdateNodeAnnotations"
	Core_UnScheduleNode_FullMethodName          = "/kantaloupev1.Core/UnScheduleNode"
	Core_ScheduleNode_FullMethodName            = "/kantaloupev1.Core/ScheduleNode"
	Core_GetConfigMap_FullMethodName            = "/kantaloupev1.Core/GetConfigMap"
	Core_GetConfigMapJSON_FullMethodName        = "/kantaloupev1.Core/GetConfigMapJSON"
	Core_UpdateConfigMap_FullMethodName         = "/kantaloupev1.Core/UpdateConfigMap"
)

// CoreClient is the client API for Core service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CoreClient interface {
	// ListPersistentVolumes lists persistentvolumes in the specified cluster
	ListPersistentVolumes(ctx context.Context, in *v1alpha12.ListPersistentVolumesRequest, opts ...grpc.CallOption) (*v1alpha12.ListPersistentVolumesResponse, error)
	// GetPersistentVolume gets a persistentvolume from the system by given persistentvolume name
	GetPersistentVolume(ctx context.Context, in *v1alpha12.GetPersistentVolumeRequest, opts ...grpc.CallOption) (*v1alpha12.GetPersistentVolumeResponse, error)
	// GetPersistentVolumeJSON gets a persistentvolume json from the system by given persistentvolume name
	GetPersistentVolumeJSON(ctx context.Context, in *v1alpha12.GetPersistentVolumeJSONRequest, opts ...grpc.CallOption) (*v1alpha12.GetPersistentVolumeResponse, error)
	// CreatePersistentVolume creates a persistentvolume to the system by given persistentvolume data
	CreatePersistentVolume(ctx context.Context, in *v1alpha12.CreatePersistentVolumeRequest, opts ...grpc.CallOption) (*v1alpha12.CreatePersistentVolumeResponse, error)
	// UpdatePersistentVolume updates a persistentvolume from the system by given persistentvolume name
	UpdatePersistentVolume(ctx context.Context, in *v1alpha12.UpdatePersistentVolumeRequest, opts ...grpc.CallOption) (*v1alpha12.UpdatePersistentVolumeResponse, error)
	// DeletePersistentVolume deletes a persistentvolume from the system by given persistentvolume name
	DeletePersistentVolume(ctx context.Context, in *v1alpha12.DeletePersistentVolumeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteSecret deletes a secret under the namespaces of a specific cluster
	DeleteSecret(ctx context.Context, in *v1alpha12.DeleteSecretRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetClusterSecret gets a secret under the namespaces of a specific cluster
	GetSecret(ctx context.Context, in *v1alpha12.GetSecretRequest, opts ...grpc.CallOption) (*v1alpha12.Secret, error)
	// ListSecrets lists a secret under the namespaces of a specific cluster
	ListSecrets(ctx context.Context, in *v1alpha12.ListSecretsRequest, opts ...grpc.CallOption) (*v1alpha12.ListSecretsResponse, error)
	// CreateSecret creates a secret under the namespaces of a specific cluster
	CreateSecret(ctx context.Context, in *v1alpha12.CreateSecretRequest, opts ...grpc.CallOption) (*v1alpha12.CreateSecretResponse, error)
	// ListClusterNamespaces gets all the namespaces of given cluster
	ListClusterNamespaces(ctx context.Context, in *v1alpha12.ListClusterNamespacesRequest, opts ...grpc.CallOption) (*v1alpha12.ListClusterNamespacesResponse, error)
	// ListClusterGPUSummary lists gpu summary of all nodes of the specified cluster.
	ListClusterGPUSummary(ctx context.Context, in *v1alpha12.ListClusterGPUSummaryRequest, opts ...grpc.CallOption) (*v1alpha12.ListClusterGPUSummaryResponse, error)
	// ListClusterEvents lists all events in the specified cluster,
	// regardless of namespace.
	ListClusterEvents(ctx context.Context, in *v1alpha12.ListClusterEventsRequest, opts ...grpc.CallOption) (*v1alpha12.ListClusterEventsResponse, error)
	// ListEvents lists events under the namespaces of a specific cluster
	ListEvents(ctx context.Context, in *v1alpha12.ListEventsRequest, opts ...grpc.CallOption) (*v1alpha12.ListEventsResponse, error)
	// ListNodes lists nodes under the specific node
	ListNodes(ctx context.Context, in *v1alpha12.ListNodesRequest, opts ...grpc.CallOption) (*v1alpha12.ListNodesResponse, error)
	// GetNode gets the details of the specified node
	GetNode(ctx context.Context, in *v1alpha12.GetNodeRequest, opts ...grpc.CallOption) (*v1alpha12.Node, error)
	// PutNodeLabels puts the specified node's labels
	PutNodeLabels(ctx context.Context, in *v1alpha12.PutNodeLabelsRequest, opts ...grpc.CallOption) (*v1alpha12.PutNodeLabelsResponse, error)
	// PutNodeTaints puts a node's taints in a specific cluster
	PutNodeTaints(ctx context.Context, in *v1alpha12.PutNodeTaintsRequest, opts ...grpc.CallOption) (*v1alpha12.PutNodeTaintsResponse, error)
	// UpdateNodeAnnotations edits annotations of specified node.
	UpdateNodeAnnotations(ctx context.Context, in *v1alpha12.UpdateNodeAnnotationsRequest, opts ...grpc.CallOption) (*v1alpha12.UpdateNodeAnnotationsResponse, error)
	// UnScheduleNode makes the specified node to unschedulable.
	UnScheduleNode(ctx context.Context, in *v1alpha12.ScheduleNodeRequest, opts ...grpc.CallOption) (*v1alpha12.Node, error)
	// ScheduleNode makes the specified node to schedulable.
	ScheduleNode(ctx context.Context, in *v1alpha12.ScheduleNodeRequest, opts ...grpc.CallOption) (*v1alpha12.Node, error)
	// GetConfigMap gets a configMap under the namespaces of a specific cluster
	GetConfigMap(ctx context.Context, in *v1alpha12.GetConfigMapRequest, opts ...grpc.CallOption) (*v1alpha12.ConfigMap, error)
	// GetConfigMapJSON gets a configMap json under the namespaces of a specific cluster
	GetConfigMapJSON(ctx context.Context, in *v1alpha12.GetConfigMapJSONRequest, opts ...grpc.CallOption) (*v1alpha12.GetConfigMapJSONResponse, error)
	// UpdateConfigMap updates a configMap under the namespaces of a specific cluster
	UpdateConfigMap(ctx context.Context, in *v1alpha12.UpdateConfigMapRequest, opts ...grpc.CallOption) (*v1alpha12.UpdateConfigMapResponse, error)
}

type coreClient struct {
	cc grpc.ClientConnInterface
}

func NewCoreClient(cc grpc.ClientConnInterface) CoreClient {
	return &coreClient{cc}
}

func (c *coreClient) ListPersistentVolumes(ctx context.Context, in *v1alpha12.ListPersistentVolumesRequest, opts ...grpc.CallOption) (*v1alpha12.ListPersistentVolumesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ListPersistentVolumesResponse)
	err := c.cc.Invoke(ctx, Core_ListPersistentVolumes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetPersistentVolume(ctx context.Context, in *v1alpha12.GetPersistentVolumeRequest, opts ...grpc.CallOption) (*v1alpha12.GetPersistentVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.GetPersistentVolumeResponse)
	err := c.cc.Invoke(ctx, Core_GetPersistentVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetPersistentVolumeJSON(ctx context.Context, in *v1alpha12.GetPersistentVolumeJSONRequest, opts ...grpc.CallOption) (*v1alpha12.GetPersistentVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.GetPersistentVolumeResponse)
	err := c.cc.Invoke(ctx, Core_GetPersistentVolumeJSON_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) CreatePersistentVolume(ctx context.Context, in *v1alpha12.CreatePersistentVolumeRequest, opts ...grpc.CallOption) (*v1alpha12.CreatePersistentVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.CreatePersistentVolumeResponse)
	err := c.cc.Invoke(ctx, Core_CreatePersistentVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UpdatePersistentVolume(ctx context.Context, in *v1alpha12.UpdatePersistentVolumeRequest, opts ...grpc.CallOption) (*v1alpha12.UpdatePersistentVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.UpdatePersistentVolumeResponse)
	err := c.cc.Invoke(ctx, Core_UpdatePersistentVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DeletePersistentVolume(ctx context.Context, in *v1alpha12.DeletePersistentVolumeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Core_DeletePersistentVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DeleteSecret(ctx context.Context, in *v1alpha12.DeleteSecretRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Core_DeleteSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetSecret(ctx context.Context, in *v1alpha12.GetSecretRequest, opts ...grpc.CallOption) (*v1alpha12.Secret, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.Secret)
	err := c.cc.Invoke(ctx, Core_GetSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ListSecrets(ctx context.Context, in *v1alpha12.ListSecretsRequest, opts ...grpc.CallOption) (*v1alpha12.ListSecretsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ListSecretsResponse)
	err := c.cc.Invoke(ctx, Core_ListSecrets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) CreateSecret(ctx context.Context, in *v1alpha12.CreateSecretRequest, opts ...grpc.CallOption) (*v1alpha12.CreateSecretResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.CreateSecretResponse)
	err := c.cc.Invoke(ctx, Core_CreateSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ListClusterNamespaces(ctx context.Context, in *v1alpha12.ListClusterNamespacesRequest, opts ...grpc.CallOption) (*v1alpha12.ListClusterNamespacesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ListClusterNamespacesResponse)
	err := c.cc.Invoke(ctx, Core_ListClusterNamespaces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ListClusterGPUSummary(ctx context.Context, in *v1alpha12.ListClusterGPUSummaryRequest, opts ...grpc.CallOption) (*v1alpha12.ListClusterGPUSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ListClusterGPUSummaryResponse)
	err := c.cc.Invoke(ctx, Core_ListClusterGPUSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ListClusterEvents(ctx context.Context, in *v1alpha12.ListClusterEventsRequest, opts ...grpc.CallOption) (*v1alpha12.ListClusterEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ListClusterEventsResponse)
	err := c.cc.Invoke(ctx, Core_ListClusterEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ListEvents(ctx context.Context, in *v1alpha12.ListEventsRequest, opts ...grpc.CallOption) (*v1alpha12.ListEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ListEventsResponse)
	err := c.cc.Invoke(ctx, Core_ListEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ListNodes(ctx context.Context, in *v1alpha12.ListNodesRequest, opts ...grpc.CallOption) (*v1alpha12.ListNodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ListNodesResponse)
	err := c.cc.Invoke(ctx, Core_ListNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetNode(ctx context.Context, in *v1alpha12.GetNodeRequest, opts ...grpc.CallOption) (*v1alpha12.Node, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.Node)
	err := c.cc.Invoke(ctx, Core_GetNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) PutNodeLabels(ctx context.Context, in *v1alpha12.PutNodeLabelsRequest, opts ...grpc.CallOption) (*v1alpha12.PutNodeLabelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.PutNodeLabelsResponse)
	err := c.cc.Invoke(ctx, Core_PutNodeLabels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) PutNodeTaints(ctx context.Context, in *v1alpha12.PutNodeTaintsRequest, opts ...grpc.CallOption) (*v1alpha12.PutNodeTaintsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.PutNodeTaintsResponse)
	err := c.cc.Invoke(ctx, Core_PutNodeTaints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UpdateNodeAnnotations(ctx context.Context, in *v1alpha12.UpdateNodeAnnotationsRequest, opts ...grpc.CallOption) (*v1alpha12.UpdateNodeAnnotationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.UpdateNodeAnnotationsResponse)
	err := c.cc.Invoke(ctx, Core_UpdateNodeAnnotations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UnScheduleNode(ctx context.Context, in *v1alpha12.ScheduleNodeRequest, opts ...grpc.CallOption) (*v1alpha12.Node, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.Node)
	err := c.cc.Invoke(ctx, Core_UnScheduleNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) ScheduleNode(ctx context.Context, in *v1alpha12.ScheduleNodeRequest, opts ...grpc.CallOption) (*v1alpha12.Node, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.Node)
	err := c.cc.Invoke(ctx, Core_ScheduleNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetConfigMap(ctx context.Context, in *v1alpha12.GetConfigMapRequest, opts ...grpc.CallOption) (*v1alpha12.ConfigMap, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.ConfigMap)
	err := c.cc.Invoke(ctx, Core_GetConfigMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) GetConfigMapJSON(ctx context.Context, in *v1alpha12.GetConfigMapJSONRequest, opts ...grpc.CallOption) (*v1alpha12.GetConfigMapJSONResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.GetConfigMapJSONResponse)
	err := c.cc.Invoke(ctx, Core_GetConfigMapJSON_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UpdateConfigMap(ctx context.Context, in *v1alpha12.UpdateConfigMapRequest, opts ...grpc.CallOption) (*v1alpha12.UpdateConfigMapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha12.UpdateConfigMapResponse)
	err := c.cc.Invoke(ctx, Core_UpdateConfigMap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoreServer is the server API for Core service.
// All implementations must embed UnimplementedCoreServer
// for forward compatibility.
type CoreServer interface {
	// ListPersistentVolumes lists persistentvolumes in the specified cluster
	ListPersistentVolumes(context.Context, *v1alpha12.ListPersistentVolumesRequest) (*v1alpha12.ListPersistentVolumesResponse, error)
	// GetPersistentVolume gets a persistentvolume from the system by given persistentvolume name
	GetPersistentVolume(context.Context, *v1alpha12.GetPersistentVolumeRequest) (*v1alpha12.GetPersistentVolumeResponse, error)
	// GetPersistentVolumeJSON gets a persistentvolume json from the system by given persistentvolume name
	GetPersistentVolumeJSON(context.Context, *v1alpha12.GetPersistentVolumeJSONRequest) (*v1alpha12.GetPersistentVolumeResponse, error)
	// CreatePersistentVolume creates a persistentvolume to the system by given persistentvolume data
	CreatePersistentVolume(context.Context, *v1alpha12.CreatePersistentVolumeRequest) (*v1alpha12.CreatePersistentVolumeResponse, error)
	// UpdatePersistentVolume updates a persistentvolume from the system by given persistentvolume name
	UpdatePersistentVolume(context.Context, *v1alpha12.UpdatePersistentVolumeRequest) (*v1alpha12.UpdatePersistentVolumeResponse, error)
	// DeletePersistentVolume deletes a persistentvolume from the system by given persistentvolume name
	DeletePersistentVolume(context.Context, *v1alpha12.DeletePersistentVolumeRequest) (*emptypb.Empty, error)
	// DeleteSecret deletes a secret under the namespaces of a specific cluster
	DeleteSecret(context.Context, *v1alpha12.DeleteSecretRequest) (*emptypb.Empty, error)
	// GetClusterSecret gets a secret under the namespaces of a specific cluster
	GetSecret(context.Context, *v1alpha12.GetSecretRequest) (*v1alpha12.Secret, error)
	// ListSecrets lists a secret under the namespaces of a specific cluster
	ListSecrets(context.Context, *v1alpha12.ListSecretsRequest) (*v1alpha12.ListSecretsResponse, error)
	// CreateSecret creates a secret under the namespaces of a specific cluster
	CreateSecret(context.Context, *v1alpha12.CreateSecretRequest) (*v1alpha12.CreateSecretResponse, error)
	// ListClusterNamespaces gets all the namespaces of given cluster
	ListClusterNamespaces(context.Context, *v1alpha12.ListClusterNamespacesRequest) (*v1alpha12.ListClusterNamespacesResponse, error)
	// ListClusterGPUSummary lists gpu summary of all nodes of the specified cluster.
	ListClusterGPUSummary(context.Context, *v1alpha12.ListClusterGPUSummaryRequest) (*v1alpha12.ListClusterGPUSummaryResponse, error)
	// ListClusterEvents lists all events in the specified cluster,
	// regardless of namespace.
	ListClusterEvents(context.Context, *v1alpha12.ListClusterEventsRequest) (*v1alpha12.ListClusterEventsResponse, error)
	// ListEvents lists events under the namespaces of a specific cluster
	ListEvents(context.Context, *v1alpha12.ListEventsRequest) (*v1alpha12.ListEventsResponse, error)
	// ListNodes lists nodes under the specific node
	ListNodes(context.Context, *v1alpha12.ListNodesRequest) (*v1alpha12.ListNodesResponse, error)
	// GetNode gets the details of the specified node
	GetNode(context.Context, *v1alpha12.GetNodeRequest) (*v1alpha12.Node, error)
	// PutNodeLabels puts the specified node's labels
	PutNodeLabels(context.Context, *v1alpha12.PutNodeLabelsRequest) (*v1alpha12.PutNodeLabelsResponse, error)
	// PutNodeTaints puts a node's taints in a specific cluster
	PutNodeTaints(context.Context, *v1alpha12.PutNodeTaintsRequest) (*v1alpha12.PutNodeTaintsResponse, error)
	// UpdateNodeAnnotations edits annotations of specified node.
	UpdateNodeAnnotations(context.Context, *v1alpha12.UpdateNodeAnnotationsRequest) (*v1alpha12.UpdateNodeAnnotationsResponse, error)
	// UnScheduleNode makes the specified node to unschedulable.
	UnScheduleNode(context.Context, *v1alpha12.ScheduleNodeRequest) (*v1alpha12.Node, error)
	// ScheduleNode makes the specified node to schedulable.
	ScheduleNode(context.Context, *v1alpha12.ScheduleNodeRequest) (*v1alpha12.Node, error)
	// GetConfigMap gets a configMap under the namespaces of a specific cluster
	GetConfigMap(context.Context, *v1alpha12.GetConfigMapRequest) (*v1alpha12.ConfigMap, error)
	// GetConfigMapJSON gets a configMap json under the namespaces of a specific cluster
	GetConfigMapJSON(context.Context, *v1alpha12.GetConfigMapJSONRequest) (*v1alpha12.GetConfigMapJSONResponse, error)
	// UpdateConfigMap updates a configMap under the namespaces of a specific cluster
	UpdateConfigMap(context.Context, *v1alpha12.UpdateConfigMapRequest) (*v1alpha12.UpdateConfigMapResponse, error)
	mustEmbedUnimplementedCoreServer()
}

// UnimplementedCoreServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCoreServer struct{}

func (UnimplementedCoreServer) ListPersistentVolumes(context.Context, *v1alpha12.ListPersistentVolumesRequest) (*v1alpha12.ListPersistentVolumesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPersistentVolumes not implemented")
}
func (UnimplementedCoreServer) GetPersistentVolume(context.Context, *v1alpha12.GetPersistentVolumeRequest) (*v1alpha12.GetPersistentVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPersistentVolume not implemented")
}
func (UnimplementedCoreServer) GetPersistentVolumeJSON(context.Context, *v1alpha12.GetPersistentVolumeJSONRequest) (*v1alpha12.GetPersistentVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPersistentVolumeJSON not implemented")
}
func (UnimplementedCoreServer) CreatePersistentVolume(context.Context, *v1alpha12.CreatePersistentVolumeRequest) (*v1alpha12.CreatePersistentVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePersistentVolume not implemented")
}
func (UnimplementedCoreServer) UpdatePersistentVolume(context.Context, *v1alpha12.UpdatePersistentVolumeRequest) (*v1alpha12.UpdatePersistentVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePersistentVolume not implemented")
}
func (UnimplementedCoreServer) DeletePersistentVolume(context.Context, *v1alpha12.DeletePersistentVolumeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePersistentVolume not implemented")
}
func (UnimplementedCoreServer) DeleteSecret(context.Context, *v1alpha12.DeleteSecretRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSecret not implemented")
}
func (UnimplementedCoreServer) GetSecret(context.Context, *v1alpha12.GetSecretRequest) (*v1alpha12.Secret, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSecret not implemented")
}
func (UnimplementedCoreServer) ListSecrets(context.Context, *v1alpha12.ListSecretsRequest) (*v1alpha12.ListSecretsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSecrets not implemented")
}
func (UnimplementedCoreServer) CreateSecret(context.Context, *v1alpha12.CreateSecretRequest) (*v1alpha12.CreateSecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSecret not implemented")
}
func (UnimplementedCoreServer) ListClusterNamespaces(context.Context, *v1alpha12.ListClusterNamespacesRequest) (*v1alpha12.ListClusterNamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClusterNamespaces not implemented")
}
func (UnimplementedCoreServer) ListClusterGPUSummary(context.Context, *v1alpha12.ListClusterGPUSummaryRequest) (*v1alpha12.ListClusterGPUSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClusterGPUSummary not implemented")
}
func (UnimplementedCoreServer) ListClusterEvents(context.Context, *v1alpha12.ListClusterEventsRequest) (*v1alpha12.ListClusterEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListClusterEvents not implemented")
}
func (UnimplementedCoreServer) ListEvents(context.Context, *v1alpha12.ListEventsRequest) (*v1alpha12.ListEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListEvents not implemented")
}
func (UnimplementedCoreServer) ListNodes(context.Context, *v1alpha12.ListNodesRequest) (*v1alpha12.ListNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedCoreServer) GetNode(context.Context, *v1alpha12.GetNodeRequest) (*v1alpha12.Node, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
}
func (UnimplementedCoreServer) PutNodeLabels(context.Context, *v1alpha12.PutNodeLabelsRequest) (*v1alpha12.PutNodeLabelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutNodeLabels not implemented")
}
func (UnimplementedCoreServer) PutNodeTaints(context.Context, *v1alpha12.PutNodeTaintsRequest) (*v1alpha12.PutNodeTaintsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutNodeTaints not implemented")
}
func (UnimplementedCoreServer) UpdateNodeAnnotations(context.Context, *v1alpha12.UpdateNodeAnnotationsRequest) (*v1alpha12.UpdateNodeAnnotationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNodeAnnotations not implemented")
}
func (UnimplementedCoreServer) UnScheduleNode(context.Context, *v1alpha12.ScheduleNodeRequest) (*v1alpha12.Node, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnScheduleNode not implemented")
}
func (UnimplementedCoreServer) ScheduleNode(context.Context, *v1alpha12.ScheduleNodeRequest) (*v1alpha12.Node, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScheduleNode not implemented")
}
func (UnimplementedCoreServer) GetConfigMap(context.Context, *v1alpha12.GetConfigMapRequest) (*v1alpha12.ConfigMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigMap not implemented")
}
func (UnimplementedCoreServer) GetConfigMapJSON(context.Context, *v1alpha12.GetConfigMapJSONRequest) (*v1alpha12.GetConfigMapJSONResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigMapJSON not implemented")
}
func (UnimplementedCoreServer) UpdateConfigMap(context.Context, *v1alpha12.UpdateConfigMapRequest) (*v1alpha12.UpdateConfigMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfigMap not implemented")
}
func (UnimplementedCoreServer) mustEmbedUnimplementedCoreServer() {}
func (UnimplementedCoreServer) testEmbeddedByValue()              {}

// UnsafeCoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CoreServer will
// result in compilation errors.
type UnsafeCoreServer interface {
	mustEmbedUnimplementedCoreServer()
}

func RegisterCoreServer(s grpc.ServiceRegistrar, srv CoreServer) {
	// If the following call pancis, it indicates UnimplementedCoreServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Core_ServiceDesc, srv)
}

func _Core_ListPersistentVolumes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ListPersistentVolumesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListPersistentVolumes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ListPersistentVolumes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListPersistentVolumes(ctx, req.(*v1alpha12.ListPersistentVolumesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetPersistentVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.GetPersistentVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).GetPersistentVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_GetPersistentVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).GetPersistentVolume(ctx, req.(*v1alpha12.GetPersistentVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetPersistentVolumeJSON_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.GetPersistentVolumeJSONRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).GetPersistentVolumeJSON(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_GetPersistentVolumeJSON_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).GetPersistentVolumeJSON(ctx, req.(*v1alpha12.GetPersistentVolumeJSONRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_CreatePersistentVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.CreatePersistentVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).CreatePersistentVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_CreatePersistentVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).CreatePersistentVolume(ctx, req.(*v1alpha12.CreatePersistentVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UpdatePersistentVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.UpdatePersistentVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UpdatePersistentVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_UpdatePersistentVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UpdatePersistentVolume(ctx, req.(*v1alpha12.UpdatePersistentVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DeletePersistentVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.DeletePersistentVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DeletePersistentVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_DeletePersistentVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DeletePersistentVolume(ctx, req.(*v1alpha12.DeletePersistentVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DeleteSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.DeleteSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DeleteSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_DeleteSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DeleteSecret(ctx, req.(*v1alpha12.DeleteSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.GetSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).GetSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_GetSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).GetSecret(ctx, req.(*v1alpha12.GetSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ListSecrets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ListSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListSecrets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ListSecrets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListSecrets(ctx, req.(*v1alpha12.ListSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_CreateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.CreateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).CreateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_CreateSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).CreateSecret(ctx, req.(*v1alpha12.CreateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ListClusterNamespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ListClusterNamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListClusterNamespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ListClusterNamespaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListClusterNamespaces(ctx, req.(*v1alpha12.ListClusterNamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ListClusterGPUSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ListClusterGPUSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListClusterGPUSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ListClusterGPUSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListClusterGPUSummary(ctx, req.(*v1alpha12.ListClusterGPUSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ListClusterEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ListClusterEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListClusterEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ListClusterEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListClusterEvents(ctx, req.(*v1alpha12.ListClusterEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ListEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ListEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ListEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListEvents(ctx, req.(*v1alpha12.ListEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ListNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ListNodes(ctx, req.(*v1alpha12.ListNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_GetNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).GetNode(ctx, req.(*v1alpha12.GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_PutNodeLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.PutNodeLabelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).PutNodeLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_PutNodeLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).PutNodeLabels(ctx, req.(*v1alpha12.PutNodeLabelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_PutNodeTaints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.PutNodeTaintsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).PutNodeTaints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_PutNodeTaints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).PutNodeTaints(ctx, req.(*v1alpha12.PutNodeTaintsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UpdateNodeAnnotations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.UpdateNodeAnnotationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UpdateNodeAnnotations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_UpdateNodeAnnotations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UpdateNodeAnnotations(ctx, req.(*v1alpha12.UpdateNodeAnnotationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UnScheduleNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ScheduleNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UnScheduleNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_UnScheduleNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UnScheduleNode(ctx, req.(*v1alpha12.ScheduleNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_ScheduleNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.ScheduleNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).ScheduleNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_ScheduleNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).ScheduleNode(ctx, req.(*v1alpha12.ScheduleNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.GetConfigMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).GetConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_GetConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).GetConfigMap(ctx, req.(*v1alpha12.GetConfigMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_GetConfigMapJSON_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.GetConfigMapJSONRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).GetConfigMapJSON(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_GetConfigMapJSON_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).GetConfigMapJSON(ctx, req.(*v1alpha12.GetConfigMapJSONRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UpdateConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha12.UpdateConfigMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UpdateConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Core_UpdateConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UpdateConfigMap(ctx, req.(*v1alpha12.UpdateConfigMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Core_ServiceDesc is the grpc.ServiceDesc for Core service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Core_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.Core",
	HandlerType: (*CoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListPersistentVolumes",
			Handler:    _Core_ListPersistentVolumes_Handler,
		},
		{
			MethodName: "GetPersistentVolume",
			Handler:    _Core_GetPersistentVolume_Handler,
		},
		{
			MethodName: "GetPersistentVolumeJSON",
			Handler:    _Core_GetPersistentVolumeJSON_Handler,
		},
		{
			MethodName: "CreatePersistentVolume",
			Handler:    _Core_CreatePersistentVolume_Handler,
		},
		{
			MethodName: "UpdatePersistentVolume",
			Handler:    _Core_UpdatePersistentVolume_Handler,
		},
		{
			MethodName: "DeletePersistentVolume",
			Handler:    _Core_DeletePersistentVolume_Handler,
		},
		{
			MethodName: "DeleteSecret",
			Handler:    _Core_DeleteSecret_Handler,
		},
		{
			MethodName: "GetSecret",
			Handler:    _Core_GetSecret_Handler,
		},
		{
			MethodName: "ListSecrets",
			Handler:    _Core_ListSecrets_Handler,
		},
		{
			MethodName: "CreateSecret",
			Handler:    _Core_CreateSecret_Handler,
		},
		{
			MethodName: "ListClusterNamespaces",
			Handler:    _Core_ListClusterNamespaces_Handler,
		},
		{
			MethodName: "ListClusterGPUSummary",
			Handler:    _Core_ListClusterGPUSummary_Handler,
		},
		{
			MethodName: "ListClusterEvents",
			Handler:    _Core_ListClusterEvents_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _Core_ListEvents_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _Core_ListNodes_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _Core_GetNode_Handler,
		},
		{
			MethodName: "PutNodeLabels",
			Handler:    _Core_PutNodeLabels_Handler,
		},
		{
			MethodName: "PutNodeTaints",
			Handler:    _Core_PutNodeTaints_Handler,
		},
		{
			MethodName: "UpdateNodeAnnotations",
			Handler:    _Core_UpdateNodeAnnotations_Handler,
		},
		{
			MethodName: "UnScheduleNode",
			Handler:    _Core_UnScheduleNode_Handler,
		},
		{
			MethodName: "ScheduleNode",
			Handler:    _Core_ScheduleNode_Handler,
		},
		{
			MethodName: "GetConfigMap",
			Handler:    _Core_GetConfigMap_Handler,
		},
		{
			MethodName: "GetConfigMapJSON",
			Handler:    _Core_GetConfigMapJSON_Handler,
		},
		{
			MethodName: "UpdateConfigMap",
			Handler:    _Core_UpdateConfigMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}

const (
	Monitoring_ListAllPodsGPUUtilization_FullMethodName           = "/kantaloupev1.Monitoring/ListAllPodsGPUUtilization"
	Monitoring_GetResourceTrend_FullMethodName                    = "/kantaloupev1.Monitoring/GetResourceTrend"
	Monitoring_GetNodeResourceTrend_FullMethodName                = "/kantaloupev1.Monitoring/GetNodeResourceTrend"
	Monitoring_GetGpuResourceTrend_FullMethodName                 = "/kantaloupev1.Monitoring/GetGpuResourceTrend"
	Monitoring_GetKantaloupeflowResourceTrend_FullMethodName      = "/kantaloupev1.Monitoring/GetKantaloupeflowResourceTrend"
	Monitoring_GetNodeWorkloadDistribution_FullMethodName         = "/kantaloupev1.Monitoring/GetNodeWorkloadDistribution"
	Monitoring_GetClusterWorkloadDistribution_FullMethodName      = "/kantaloupev1.Monitoring/GetClusterWorkloadDistribution"
	Monitoring_GetTopNodes_FullMethodName                         = "/kantaloupev1.Monitoring/GetTopNodes"
	Monitoring_GetTopNodeWorkloads_FullMethodName                 = "/kantaloupev1.Monitoring/GetTopNodeWorkloads"
	Monitoring_GetKantaloupeflowMemoryDistribution_FullMethodName = "/kantaloupev1.Monitoring/GetKantaloupeflowMemoryDistribution"
	Monitoring_GetCardTopWorkloads_FullMethodName                 = "/kantaloupev1.Monitoring/GetCardTopWorkloads"
	Monitoring_GetClusterWorkloadsTop_FullMethodName              = "/kantaloupev1.Monitoring/GetClusterWorkloadsTop"
)

// MonitoringClient is the client API for Monitoring service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MonitoringClient interface {
	ListAllPodsGPUUtilization(ctx context.Context, in *v1alpha11.ListMonitoringsRequest, opts ...grpc.CallOption) (*v1alpha11.ListMonitoringsResponse, error)
	// GetResourceTrend returns the resource utilization trend for a specific resource type
	GetResourceTrend(ctx context.Context, in *v1alpha11.ResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error)
	// GetNodeResourceTrend returns the resource utilization trend for a specific node
	GetNodeResourceTrend(ctx context.Context, in *v1alpha11.NodeResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error)
	// GetGpuResourceTrend returns the resource utilization trend and status for a specific GPU
	GetGpuResourceTrend(ctx context.Context, in *v1alpha11.GpuResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error)
	// GetKantaloupeflowResourceTrend returns the resource utilization trend for a specific kantalouepflow
	GetKantaloupeflowResourceTrend(ctx context.Context, in *v1alpha11.KantaloupeflowResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error)
	// GetNodeWorkloadDistribution returns the workload distribution for a specific node
	GetNodeWorkloadDistribution(ctx context.Context, in *v1alpha11.NodeWorkloadDistributionRequest, opts ...grpc.CallOption) (*v1alpha11.WorkloadDistributionResponse, error)
	// GetClusterWorkloadDistribution returns the workload distribution across the cluster
	GetClusterWorkloadDistribution(ctx context.Context, in *v1alpha11.ClusterWorkloadDistributionRequest, opts ...grpc.CallOption) (*v1alpha11.WorkloadDistributionResponse, error)
	// Get top K nodes by resource usage
	GetTopNodes(ctx context.Context, in *v1alpha11.TopNodeRequest, opts ...grpc.CallOption) (*v1alpha11.TopNodeResponse, error)
	// Get top K nodes by workload count
	GetTopNodeWorkloads(ctx context.Context, in *v1alpha11.TopNodeWorkloadRequest, opts ...grpc.CallOption) (*v1alpha11.TopNodeResponse, error)
	GetKantaloupeflowMemoryDistribution(ctx context.Context, in *v1alpha11.MemoryDistributionRequest, opts ...grpc.CallOption) (*v1alpha11.MemoryDistributionResponse, error)
	GetCardTopWorkloads(ctx context.Context, in *v1alpha11.CardTopWorkloadsRequest, opts ...grpc.CallOption) (*v1alpha11.CardTopWorkloadsResponse, error)
	GetClusterWorkloadsTop(ctx context.Context, in *v1alpha11.GetClusterWorkloadsTopRequest, opts ...grpc.CallOption) (*v1alpha11.GetClusterWorkloadsTopResponse, error)
}

type monitoringClient struct {
	cc grpc.ClientConnInterface
}

func NewMonitoringClient(cc grpc.ClientConnInterface) MonitoringClient {
	return &monitoringClient{cc}
}

func (c *monitoringClient) ListAllPodsGPUUtilization(ctx context.Context, in *v1alpha11.ListMonitoringsRequest, opts ...grpc.CallOption) (*v1alpha11.ListMonitoringsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.ListMonitoringsResponse)
	err := c.cc.Invoke(ctx, Monitoring_ListAllPodsGPUUtilization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetResourceTrend(ctx context.Context, in *v1alpha11.ResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.ResourceTrendResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetResourceTrend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetNodeResourceTrend(ctx context.Context, in *v1alpha11.NodeResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.ResourceTrendResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetNodeResourceTrend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetGpuResourceTrend(ctx context.Context, in *v1alpha11.GpuResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.ResourceTrendResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetGpuResourceTrend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetKantaloupeflowResourceTrend(ctx context.Context, in *v1alpha11.KantaloupeflowResourceTrendRequest, opts ...grpc.CallOption) (*v1alpha11.ResourceTrendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.ResourceTrendResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetKantaloupeflowResourceTrend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetNodeWorkloadDistribution(ctx context.Context, in *v1alpha11.NodeWorkloadDistributionRequest, opts ...grpc.CallOption) (*v1alpha11.WorkloadDistributionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.WorkloadDistributionResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetNodeWorkloadDistribution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetClusterWorkloadDistribution(ctx context.Context, in *v1alpha11.ClusterWorkloadDistributionRequest, opts ...grpc.CallOption) (*v1alpha11.WorkloadDistributionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.WorkloadDistributionResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetClusterWorkloadDistribution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetTopNodes(ctx context.Context, in *v1alpha11.TopNodeRequest, opts ...grpc.CallOption) (*v1alpha11.TopNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.TopNodeResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetTopNodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetTopNodeWorkloads(ctx context.Context, in *v1alpha11.TopNodeWorkloadRequest, opts ...grpc.CallOption) (*v1alpha11.TopNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.TopNodeResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetTopNodeWorkloads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetKantaloupeflowMemoryDistribution(ctx context.Context, in *v1alpha11.MemoryDistributionRequest, opts ...grpc.CallOption) (*v1alpha11.MemoryDistributionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.MemoryDistributionResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetKantaloupeflowMemoryDistribution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetCardTopWorkloads(ctx context.Context, in *v1alpha11.CardTopWorkloadsRequest, opts ...grpc.CallOption) (*v1alpha11.CardTopWorkloadsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.CardTopWorkloadsResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetCardTopWorkloads_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monitoringClient) GetClusterWorkloadsTop(ctx context.Context, in *v1alpha11.GetClusterWorkloadsTopRequest, opts ...grpc.CallOption) (*v1alpha11.GetClusterWorkloadsTopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha11.GetClusterWorkloadsTopResponse)
	err := c.cc.Invoke(ctx, Monitoring_GetClusterWorkloadsTop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MonitoringServer is the server API for Monitoring service.
// All implementations must embed UnimplementedMonitoringServer
// for forward compatibility.
type MonitoringServer interface {
	ListAllPodsGPUUtilization(context.Context, *v1alpha11.ListMonitoringsRequest) (*v1alpha11.ListMonitoringsResponse, error)
	// GetResourceTrend returns the resource utilization trend for a specific resource type
	GetResourceTrend(context.Context, *v1alpha11.ResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error)
	// GetNodeResourceTrend returns the resource utilization trend for a specific node
	GetNodeResourceTrend(context.Context, *v1alpha11.NodeResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error)
	// GetGpuResourceTrend returns the resource utilization trend and status for a specific GPU
	GetGpuResourceTrend(context.Context, *v1alpha11.GpuResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error)
	// GetKantaloupeflowResourceTrend returns the resource utilization trend for a specific kantalouepflow
	GetKantaloupeflowResourceTrend(context.Context, *v1alpha11.KantaloupeflowResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error)
	// GetNodeWorkloadDistribution returns the workload distribution for a specific node
	GetNodeWorkloadDistribution(context.Context, *v1alpha11.NodeWorkloadDistributionRequest) (*v1alpha11.WorkloadDistributionResponse, error)
	// GetClusterWorkloadDistribution returns the workload distribution across the cluster
	GetClusterWorkloadDistribution(context.Context, *v1alpha11.ClusterWorkloadDistributionRequest) (*v1alpha11.WorkloadDistributionResponse, error)
	// Get top K nodes by resource usage
	GetTopNodes(context.Context, *v1alpha11.TopNodeRequest) (*v1alpha11.TopNodeResponse, error)
	// Get top K nodes by workload count
	GetTopNodeWorkloads(context.Context, *v1alpha11.TopNodeWorkloadRequest) (*v1alpha11.TopNodeResponse, error)
	GetKantaloupeflowMemoryDistribution(context.Context, *v1alpha11.MemoryDistributionRequest) (*v1alpha11.MemoryDistributionResponse, error)
	GetCardTopWorkloads(context.Context, *v1alpha11.CardTopWorkloadsRequest) (*v1alpha11.CardTopWorkloadsResponse, error)
	GetClusterWorkloadsTop(context.Context, *v1alpha11.GetClusterWorkloadsTopRequest) (*v1alpha11.GetClusterWorkloadsTopResponse, error)
	mustEmbedUnimplementedMonitoringServer()
}

// UnimplementedMonitoringServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonitoringServer struct{}

func (UnimplementedMonitoringServer) ListAllPodsGPUUtilization(context.Context, *v1alpha11.ListMonitoringsRequest) (*v1alpha11.ListMonitoringsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAllPodsGPUUtilization not implemented")
}
func (UnimplementedMonitoringServer) GetResourceTrend(context.Context, *v1alpha11.ResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResourceTrend not implemented")
}
func (UnimplementedMonitoringServer) GetNodeResourceTrend(context.Context, *v1alpha11.NodeResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeResourceTrend not implemented")
}
func (UnimplementedMonitoringServer) GetGpuResourceTrend(context.Context, *v1alpha11.GpuResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGpuResourceTrend not implemented")
}
func (UnimplementedMonitoringServer) GetKantaloupeflowResourceTrend(context.Context, *v1alpha11.KantaloupeflowResourceTrendRequest) (*v1alpha11.ResourceTrendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKantaloupeflowResourceTrend not implemented")
}
func (UnimplementedMonitoringServer) GetNodeWorkloadDistribution(context.Context, *v1alpha11.NodeWorkloadDistributionRequest) (*v1alpha11.WorkloadDistributionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeWorkloadDistribution not implemented")
}
func (UnimplementedMonitoringServer) GetClusterWorkloadDistribution(context.Context, *v1alpha11.ClusterWorkloadDistributionRequest) (*v1alpha11.WorkloadDistributionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterWorkloadDistribution not implemented")
}
func (UnimplementedMonitoringServer) GetTopNodes(context.Context, *v1alpha11.TopNodeRequest) (*v1alpha11.TopNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopNodes not implemented")
}
func (UnimplementedMonitoringServer) GetTopNodeWorkloads(context.Context, *v1alpha11.TopNodeWorkloadRequest) (*v1alpha11.TopNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopNodeWorkloads not implemented")
}
func (UnimplementedMonitoringServer) GetKantaloupeflowMemoryDistribution(context.Context, *v1alpha11.MemoryDistributionRequest) (*v1alpha11.MemoryDistributionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKantaloupeflowMemoryDistribution not implemented")
}
func (UnimplementedMonitoringServer) GetCardTopWorkloads(context.Context, *v1alpha11.CardTopWorkloadsRequest) (*v1alpha11.CardTopWorkloadsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCardTopWorkloads not implemented")
}
func (UnimplementedMonitoringServer) GetClusterWorkloadsTop(context.Context, *v1alpha11.GetClusterWorkloadsTopRequest) (*v1alpha11.GetClusterWorkloadsTopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterWorkloadsTop not implemented")
}
func (UnimplementedMonitoringServer) mustEmbedUnimplementedMonitoringServer() {}
func (UnimplementedMonitoringServer) testEmbeddedByValue()                    {}

// UnsafeMonitoringServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonitoringServer will
// result in compilation errors.
type UnsafeMonitoringServer interface {
	mustEmbedUnimplementedMonitoringServer()
}

func RegisterMonitoringServer(s grpc.ServiceRegistrar, srv MonitoringServer) {
	// If the following call pancis, it indicates UnimplementedMonitoringServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Monitoring_ServiceDesc, srv)
}

func _Monitoring_ListAllPodsGPUUtilization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.ListMonitoringsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).ListAllPodsGPUUtilization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_ListAllPodsGPUUtilization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).ListAllPodsGPUUtilization(ctx, req.(*v1alpha11.ListMonitoringsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetResourceTrend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.ResourceTrendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetResourceTrend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetResourceTrend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetResourceTrend(ctx, req.(*v1alpha11.ResourceTrendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetNodeResourceTrend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.NodeResourceTrendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetNodeResourceTrend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetNodeResourceTrend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetNodeResourceTrend(ctx, req.(*v1alpha11.NodeResourceTrendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetGpuResourceTrend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.GpuResourceTrendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetGpuResourceTrend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetGpuResourceTrend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetGpuResourceTrend(ctx, req.(*v1alpha11.GpuResourceTrendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetKantaloupeflowResourceTrend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.KantaloupeflowResourceTrendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetKantaloupeflowResourceTrend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetKantaloupeflowResourceTrend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetKantaloupeflowResourceTrend(ctx, req.(*v1alpha11.KantaloupeflowResourceTrendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetNodeWorkloadDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.NodeWorkloadDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetNodeWorkloadDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetNodeWorkloadDistribution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetNodeWorkloadDistribution(ctx, req.(*v1alpha11.NodeWorkloadDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetClusterWorkloadDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.ClusterWorkloadDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetClusterWorkloadDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetClusterWorkloadDistribution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetClusterWorkloadDistribution(ctx, req.(*v1alpha11.ClusterWorkloadDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetTopNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.TopNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetTopNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetTopNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetTopNodes(ctx, req.(*v1alpha11.TopNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetTopNodeWorkloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.TopNodeWorkloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetTopNodeWorkloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetTopNodeWorkloads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetTopNodeWorkloads(ctx, req.(*v1alpha11.TopNodeWorkloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetKantaloupeflowMemoryDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.MemoryDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetKantaloupeflowMemoryDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetKantaloupeflowMemoryDistribution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetKantaloupeflowMemoryDistribution(ctx, req.(*v1alpha11.MemoryDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetCardTopWorkloads_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.CardTopWorkloadsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetCardTopWorkloads(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetCardTopWorkloads_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetCardTopWorkloads(ctx, req.(*v1alpha11.CardTopWorkloadsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Monitoring_GetClusterWorkloadsTop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha11.GetClusterWorkloadsTopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonitoringServer).GetClusterWorkloadsTop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Monitoring_GetClusterWorkloadsTop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonitoringServer).GetClusterWorkloadsTop(ctx, req.(*v1alpha11.GetClusterWorkloadsTopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Monitoring_ServiceDesc is the grpc.ServiceDesc for Monitoring service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Monitoring_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.Monitoring",
	HandlerType: (*MonitoringServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAllPodsGPUUtilization",
			Handler:    _Monitoring_ListAllPodsGPUUtilization_Handler,
		},
		{
			MethodName: "GetResourceTrend",
			Handler:    _Monitoring_GetResourceTrend_Handler,
		},
		{
			MethodName: "GetNodeResourceTrend",
			Handler:    _Monitoring_GetNodeResourceTrend_Handler,
		},
		{
			MethodName: "GetGpuResourceTrend",
			Handler:    _Monitoring_GetGpuResourceTrend_Handler,
		},
		{
			MethodName: "GetKantaloupeflowResourceTrend",
			Handler:    _Monitoring_GetKantaloupeflowResourceTrend_Handler,
		},
		{
			MethodName: "GetNodeWorkloadDistribution",
			Handler:    _Monitoring_GetNodeWorkloadDistribution_Handler,
		},
		{
			MethodName: "GetClusterWorkloadDistribution",
			Handler:    _Monitoring_GetClusterWorkloadDistribution_Handler,
		},
		{
			MethodName: "GetTopNodes",
			Handler:    _Monitoring_GetTopNodes_Handler,
		},
		{
			MethodName: "GetTopNodeWorkloads",
			Handler:    _Monitoring_GetTopNodeWorkloads_Handler,
		},
		{
			MethodName: "GetKantaloupeflowMemoryDistribution",
			Handler:    _Monitoring_GetKantaloupeflowMemoryDistribution_Handler,
		},
		{
			MethodName: "GetCardTopWorkloads",
			Handler:    _Monitoring_GetCardTopWorkloads_Handler,
		},
		{
			MethodName: "GetClusterWorkloadsTop",
			Handler:    _Monitoring_GetClusterWorkloadsTop_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}

const (
	Kantaloupeflow_CreateKantaloupeflow_FullMethodName          = "/kantaloupev1.Kantaloupeflow/CreateKantaloupeflow"
	Kantaloupeflow_GetKantaloupeflow_FullMethodName             = "/kantaloupev1.Kantaloupeflow/GetKantaloupeflow"
	Kantaloupeflow_DeleteKantaloupeflow_FullMethodName          = "/kantaloupev1.Kantaloupeflow/DeleteKantaloupeflow"
	Kantaloupeflow_ListKantaloupeflows_FullMethodName           = "/kantaloupev1.Kantaloupeflow/ListKantaloupeflows"
	Kantaloupeflow_GetKantaloupeTree_FullMethodName             = "/kantaloupev1.Kantaloupeflow/GetKantaloupeTree"
	Kantaloupeflow_UpdateKantaloupeflowGPUMemory_FullMethodName = "/kantaloupev1.Kantaloupeflow/UpdateKantaloupeflowGPUMemory"
	Kantaloupeflow_GetKantaloupeflowConditions_FullMethodName   = "/kantaloupev1.Kantaloupeflow/GetKantaloupeflowConditions"
)

// KantaloupeflowClient is the client API for Kantaloupeflow service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KantaloupeflowClient interface {
	// CreateKantaloupeflow create a kantaloupeflow
	CreateKantaloupeflow(ctx context.Context, in *v1alpha13.CreateKantaloupeflowRequest, opts ...grpc.CallOption) (*v1alpha13.Kantaloupeflow, error)
	// GetKantaloupeflow get a specified Kantaloupeflow
	GetKantaloupeflow(ctx context.Context, in *v1alpha13.GetKantaloupeflowRequest, opts ...grpc.CallOption) (*v1alpha13.GetKantaloupeflowResponse, error)
	// DeleteKantaloupeflow delete a specified Kantaloupeflow
	DeleteKantaloupeflow(ctx context.Context, in *v1alpha13.DeleteKantaloupeflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListKantaloupeflows lists Kantaloupeflow
	ListKantaloupeflows(ctx context.Context, in *v1alpha13.ListKantaloupeflowsRequest, opts ...grpc.CallOption) (*v1alpha13.ListKantaloupeflowsResponse, error)
	GetKantaloupeTree(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*v1alpha13.KantaloupeTree, error)
	// UpdateKantaloupeflowGPUMemory update Kantaloupeflow gpu memory. Unit is MB.
	UpdateKantaloupeflowGPUMemory(ctx context.Context, in *v1alpha13.UpdateKantaloupeflowGPUMemoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetKantaloupeflowConditions(ctx context.Context, in *v1alpha13.GetKantaloupeflowConditionsRequest, opts ...grpc.CallOption) (*v1alpha13.GetKantaloupeflowConditionsResponse, error)
}

type kantaloupeflowClient struct {
	cc grpc.ClientConnInterface
}

func NewKantaloupeflowClient(cc grpc.ClientConnInterface) KantaloupeflowClient {
	return &kantaloupeflowClient{cc}
}

func (c *kantaloupeflowClient) CreateKantaloupeflow(ctx context.Context, in *v1alpha13.CreateKantaloupeflowRequest, opts ...grpc.CallOption) (*v1alpha13.Kantaloupeflow, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha13.Kantaloupeflow)
	err := c.cc.Invoke(ctx, Kantaloupeflow_CreateKantaloupeflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kantaloupeflowClient) GetKantaloupeflow(ctx context.Context, in *v1alpha13.GetKantaloupeflowRequest, opts ...grpc.CallOption) (*v1alpha13.GetKantaloupeflowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha13.GetKantaloupeflowResponse)
	err := c.cc.Invoke(ctx, Kantaloupeflow_GetKantaloupeflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kantaloupeflowClient) DeleteKantaloupeflow(ctx context.Context, in *v1alpha13.DeleteKantaloupeflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Kantaloupeflow_DeleteKantaloupeflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kantaloupeflowClient) ListKantaloupeflows(ctx context.Context, in *v1alpha13.ListKantaloupeflowsRequest, opts ...grpc.CallOption) (*v1alpha13.ListKantaloupeflowsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha13.ListKantaloupeflowsResponse)
	err := c.cc.Invoke(ctx, Kantaloupeflow_ListKantaloupeflows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kantaloupeflowClient) GetKantaloupeTree(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*v1alpha13.KantaloupeTree, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha13.KantaloupeTree)
	err := c.cc.Invoke(ctx, Kantaloupeflow_GetKantaloupeTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kantaloupeflowClient) UpdateKantaloupeflowGPUMemory(ctx context.Context, in *v1alpha13.UpdateKantaloupeflowGPUMemoryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Kantaloupeflow_UpdateKantaloupeflowGPUMemory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kantaloupeflowClient) GetKantaloupeflowConditions(ctx context.Context, in *v1alpha13.GetKantaloupeflowConditionsRequest, opts ...grpc.CallOption) (*v1alpha13.GetKantaloupeflowConditionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha13.GetKantaloupeflowConditionsResponse)
	err := c.cc.Invoke(ctx, Kantaloupeflow_GetKantaloupeflowConditions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KantaloupeflowServer is the server API for Kantaloupeflow service.
// All implementations must embed UnimplementedKantaloupeflowServer
// for forward compatibility.
type KantaloupeflowServer interface {
	// CreateKantaloupeflow create a kantaloupeflow
	CreateKantaloupeflow(context.Context, *v1alpha13.CreateKantaloupeflowRequest) (*v1alpha13.Kantaloupeflow, error)
	// GetKantaloupeflow get a specified Kantaloupeflow
	GetKantaloupeflow(context.Context, *v1alpha13.GetKantaloupeflowRequest) (*v1alpha13.GetKantaloupeflowResponse, error)
	// DeleteKantaloupeflow delete a specified Kantaloupeflow
	DeleteKantaloupeflow(context.Context, *v1alpha13.DeleteKantaloupeflowRequest) (*emptypb.Empty, error)
	// ListKantaloupeflows lists Kantaloupeflow
	ListKantaloupeflows(context.Context, *v1alpha13.ListKantaloupeflowsRequest) (*v1alpha13.ListKantaloupeflowsResponse, error)
	GetKantaloupeTree(context.Context, *emptypb.Empty) (*v1alpha13.KantaloupeTree, error)
	// UpdateKantaloupeflowGPUMemory update Kantaloupeflow gpu memory. Unit is MB.
	UpdateKantaloupeflowGPUMemory(context.Context, *v1alpha13.UpdateKantaloupeflowGPUMemoryRequest) (*emptypb.Empty, error)
	GetKantaloupeflowConditions(context.Context, *v1alpha13.GetKantaloupeflowConditionsRequest) (*v1alpha13.GetKantaloupeflowConditionsResponse, error)
	mustEmbedUnimplementedKantaloupeflowServer()
}

// UnimplementedKantaloupeflowServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKantaloupeflowServer struct{}

func (UnimplementedKantaloupeflowServer) CreateKantaloupeflow(context.Context, *v1alpha13.CreateKantaloupeflowRequest) (*v1alpha13.Kantaloupeflow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateKantaloupeflow not implemented")
}
func (UnimplementedKantaloupeflowServer) GetKantaloupeflow(context.Context, *v1alpha13.GetKantaloupeflowRequest) (*v1alpha13.GetKantaloupeflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKantaloupeflow not implemented")
}
func (UnimplementedKantaloupeflowServer) DeleteKantaloupeflow(context.Context, *v1alpha13.DeleteKantaloupeflowRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKantaloupeflow not implemented")
}
func (UnimplementedKantaloupeflowServer) ListKantaloupeflows(context.Context, *v1alpha13.ListKantaloupeflowsRequest) (*v1alpha13.ListKantaloupeflowsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListKantaloupeflows not implemented")
}
func (UnimplementedKantaloupeflowServer) GetKantaloupeTree(context.Context, *emptypb.Empty) (*v1alpha13.KantaloupeTree, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKantaloupeTree not implemented")
}
func (UnimplementedKantaloupeflowServer) UpdateKantaloupeflowGPUMemory(context.Context, *v1alpha13.UpdateKantaloupeflowGPUMemoryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKantaloupeflowGPUMemory not implemented")
}
func (UnimplementedKantaloupeflowServer) GetKantaloupeflowConditions(context.Context, *v1alpha13.GetKantaloupeflowConditionsRequest) (*v1alpha13.GetKantaloupeflowConditionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKantaloupeflowConditions not implemented")
}
func (UnimplementedKantaloupeflowServer) mustEmbedUnimplementedKantaloupeflowServer() {}
func (UnimplementedKantaloupeflowServer) testEmbeddedByValue()                        {}

// UnsafeKantaloupeflowServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KantaloupeflowServer will
// result in compilation errors.
type UnsafeKantaloupeflowServer interface {
	mustEmbedUnimplementedKantaloupeflowServer()
}

func RegisterKantaloupeflowServer(s grpc.ServiceRegistrar, srv KantaloupeflowServer) {
	// If the following call pancis, it indicates UnimplementedKantaloupeflowServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Kantaloupeflow_ServiceDesc, srv)
}

func _Kantaloupeflow_CreateKantaloupeflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha13.CreateKantaloupeflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KantaloupeflowServer).CreateKantaloupeflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kantaloupeflow_CreateKantaloupeflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KantaloupeflowServer).CreateKantaloupeflow(ctx, req.(*v1alpha13.CreateKantaloupeflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kantaloupeflow_GetKantaloupeflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha13.GetKantaloupeflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KantaloupeflowServer).GetKantaloupeflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kantaloupeflow_GetKantaloupeflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KantaloupeflowServer).GetKantaloupeflow(ctx, req.(*v1alpha13.GetKantaloupeflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kantaloupeflow_DeleteKantaloupeflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha13.DeleteKantaloupeflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KantaloupeflowServer).DeleteKantaloupeflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kantaloupeflow_DeleteKantaloupeflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KantaloupeflowServer).DeleteKantaloupeflow(ctx, req.(*v1alpha13.DeleteKantaloupeflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kantaloupeflow_ListKantaloupeflows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha13.ListKantaloupeflowsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KantaloupeflowServer).ListKantaloupeflows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kantaloupeflow_ListKantaloupeflows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KantaloupeflowServer).ListKantaloupeflows(ctx, req.(*v1alpha13.ListKantaloupeflowsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kantaloupeflow_GetKantaloupeTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KantaloupeflowServer).GetKantaloupeTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kantaloupeflow_GetKantaloupeTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KantaloupeflowServer).GetKantaloupeTree(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kantaloupeflow_UpdateKantaloupeflowGPUMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha13.UpdateKantaloupeflowGPUMemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KantaloupeflowServer).UpdateKantaloupeflowGPUMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kantaloupeflow_UpdateKantaloupeflowGPUMemory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KantaloupeflowServer).UpdateKantaloupeflowGPUMemory(ctx, req.(*v1alpha13.UpdateKantaloupeflowGPUMemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Kantaloupeflow_GetKantaloupeflowConditions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha13.GetKantaloupeflowConditionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KantaloupeflowServer).GetKantaloupeflowConditions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Kantaloupeflow_GetKantaloupeflowConditions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KantaloupeflowServer).GetKantaloupeflowConditions(ctx, req.(*v1alpha13.GetKantaloupeflowConditionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Kantaloupeflow_ServiceDesc is the grpc.ServiceDesc for Kantaloupeflow service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Kantaloupeflow_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.Kantaloupeflow",
	HandlerType: (*KantaloupeflowServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateKantaloupeflow",
			Handler:    _Kantaloupeflow_CreateKantaloupeflow_Handler,
		},
		{
			MethodName: "GetKantaloupeflow",
			Handler:    _Kantaloupeflow_GetKantaloupeflow_Handler,
		},
		{
			MethodName: "DeleteKantaloupeflow",
			Handler:    _Kantaloupeflow_DeleteKantaloupeflow_Handler,
		},
		{
			MethodName: "ListKantaloupeflows",
			Handler:    _Kantaloupeflow_ListKantaloupeflows_Handler,
		},
		{
			MethodName: "GetKantaloupeTree",
			Handler:    _Kantaloupeflow_GetKantaloupeTree_Handler,
		},
		{
			MethodName: "UpdateKantaloupeflowGPUMemory",
			Handler:    _Kantaloupeflow_UpdateKantaloupeflowGPUMemory_Handler,
		},
		{
			MethodName: "GetKantaloupeflowConditions",
			Handler:    _Kantaloupeflow_GetKantaloupeflowConditions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}

const (
	Credential_ListCredentials_FullMethodName  = "/kantaloupev1.Credential/ListCredentials"
	Credential_DeleteCredential_FullMethodName = "/kantaloupev1.Credential/DeleteCredential"
	Credential_CreateCredential_FullMethodName = "/kantaloupev1.Credential/CreateCredential"
	Credential_UpdateCredential_FullMethodName = "/kantaloupev1.Credential/UpdateCredential"
)

// CredentialClient is the client API for Credential service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CredentialClient interface {
	// ListCredentials lists credentials.
	ListCredentials(ctx context.Context, in *v1alpha14.ListCredentialsRequest, opts ...grpc.CallOption) (*v1alpha14.ListCredentialsResponse, error)
	// DeleteCredential deletes a credential.
	DeleteCredential(ctx context.Context, in *v1alpha14.DeleteCredentialRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateCredential creates a credential.
	CreateCredential(ctx context.Context, in *v1alpha14.CreateCredentialRequest, opts ...grpc.CallOption) (*v1alpha14.CredentialResponse, error)
	// UpdateCredential updates a credential.
	UpdateCredential(ctx context.Context, in *v1alpha14.UpdateCredentialRequest, opts ...grpc.CallOption) (*v1alpha14.CredentialResponse, error)
}

type credentialClient struct {
	cc grpc.ClientConnInterface
}

func NewCredentialClient(cc grpc.ClientConnInterface) CredentialClient {
	return &credentialClient{cc}
}

func (c *credentialClient) ListCredentials(ctx context.Context, in *v1alpha14.ListCredentialsRequest, opts ...grpc.CallOption) (*v1alpha14.ListCredentialsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha14.ListCredentialsResponse)
	err := c.cc.Invoke(ctx, Credential_ListCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *credentialClient) DeleteCredential(ctx context.Context, in *v1alpha14.DeleteCredentialRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Credential_DeleteCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *credentialClient) CreateCredential(ctx context.Context, in *v1alpha14.CreateCredentialRequest, opts ...grpc.CallOption) (*v1alpha14.CredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha14.CredentialResponse)
	err := c.cc.Invoke(ctx, Credential_CreateCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *credentialClient) UpdateCredential(ctx context.Context, in *v1alpha14.UpdateCredentialRequest, opts ...grpc.CallOption) (*v1alpha14.CredentialResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha14.CredentialResponse)
	err := c.cc.Invoke(ctx, Credential_UpdateCredential_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CredentialServer is the server API for Credential service.
// All implementations must embed UnimplementedCredentialServer
// for forward compatibility.
type CredentialServer interface {
	// ListCredentials lists credentials.
	ListCredentials(context.Context, *v1alpha14.ListCredentialsRequest) (*v1alpha14.ListCredentialsResponse, error)
	// DeleteCredential deletes a credential.
	DeleteCredential(context.Context, *v1alpha14.DeleteCredentialRequest) (*emptypb.Empty, error)
	// CreateCredential creates a credential.
	CreateCredential(context.Context, *v1alpha14.CreateCredentialRequest) (*v1alpha14.CredentialResponse, error)
	// UpdateCredential updates a credential.
	UpdateCredential(context.Context, *v1alpha14.UpdateCredentialRequest) (*v1alpha14.CredentialResponse, error)
	mustEmbedUnimplementedCredentialServer()
}

// UnimplementedCredentialServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCredentialServer struct{}

func (UnimplementedCredentialServer) ListCredentials(context.Context, *v1alpha14.ListCredentialsRequest) (*v1alpha14.ListCredentialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCredentials not implemented")
}
func (UnimplementedCredentialServer) DeleteCredential(context.Context, *v1alpha14.DeleteCredentialRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCredential not implemented")
}
func (UnimplementedCredentialServer) CreateCredential(context.Context, *v1alpha14.CreateCredentialRequest) (*v1alpha14.CredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCredential not implemented")
}
func (UnimplementedCredentialServer) UpdateCredential(context.Context, *v1alpha14.UpdateCredentialRequest) (*v1alpha14.CredentialResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCredential not implemented")
}
func (UnimplementedCredentialServer) mustEmbedUnimplementedCredentialServer() {}
func (UnimplementedCredentialServer) testEmbeddedByValue()                    {}

// UnsafeCredentialServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CredentialServer will
// result in compilation errors.
type UnsafeCredentialServer interface {
	mustEmbedUnimplementedCredentialServer()
}

func RegisterCredentialServer(s grpc.ServiceRegistrar, srv CredentialServer) {
	// If the following call pancis, it indicates UnimplementedCredentialServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Credential_ServiceDesc, srv)
}

func _Credential_ListCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha14.ListCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CredentialServer).ListCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Credential_ListCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CredentialServer).ListCredentials(ctx, req.(*v1alpha14.ListCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Credential_DeleteCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha14.DeleteCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CredentialServer).DeleteCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Credential_DeleteCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CredentialServer).DeleteCredential(ctx, req.(*v1alpha14.DeleteCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Credential_CreateCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha14.CreateCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CredentialServer).CreateCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Credential_CreateCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CredentialServer).CreateCredential(ctx, req.(*v1alpha14.CreateCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Credential_UpdateCredential_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha14.UpdateCredentialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CredentialServer).UpdateCredential(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Credential_UpdateCredential_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CredentialServer).UpdateCredential(ctx, req.(*v1alpha14.UpdateCredentialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Credential_ServiceDesc is the grpc.ServiceDesc for Credential service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Credential_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.Credential",
	HandlerType: (*CredentialServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListCredentials",
			Handler:    _Credential_ListCredentials_Handler,
		},
		{
			MethodName: "DeleteCredential",
			Handler:    _Credential_DeleteCredential_Handler,
		},
		{
			MethodName: "CreateCredential",
			Handler:    _Credential_CreateCredential_Handler,
		},
		{
			MethodName: "UpdateCredential",
			Handler:    _Credential_UpdateCredential_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}

const (
	Quota_ListQuotas_FullMethodName  = "/kantaloupev1.Quota/ListQuotas"
	Quota_DeleteQuota_FullMethodName = "/kantaloupev1.Quota/DeleteQuota"
	Quota_CreateQuota_FullMethodName = "/kantaloupev1.Quota/CreateQuota"
	Quota_UpdateQuota_FullMethodName = "/kantaloupev1.Quota/UpdateQuota"
	Quota_GetQuota_FullMethodName    = "/kantaloupev1.Quota/GetQuota"
)

// QuotaClient is the client API for Quota service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QuotaClient interface {
	// ListQuotas lists resource quotas.
	ListQuotas(ctx context.Context, in *v1alpha15.ListQuotasRequest, opts ...grpc.CallOption) (*v1alpha15.ListQuotasResponse, error)
	// DeleteQuota deletes a resource quota.
	DeleteQuota(ctx context.Context, in *v1alpha15.DeleteQuotaRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateQuota creates a resource quota.
	CreateQuota(ctx context.Context, in *v1alpha15.CreateQuotaRequest, opts ...grpc.CallOption) (*v1alpha15.QuotaResponse, error)
	// UpdateQuota updates a resource quota.
	UpdateQuota(ctx context.Context, in *v1alpha15.UpdateQuotaRequest, opts ...grpc.CallOption) (*v1alpha15.QuotaResponse, error)
	GetQuota(ctx context.Context, in *v1alpha15.GetQuotaRequest, opts ...grpc.CallOption) (*v1alpha15.QuotaResponse, error)
}

type quotaClient struct {
	cc grpc.ClientConnInterface
}

func NewQuotaClient(cc grpc.ClientConnInterface) QuotaClient {
	return &quotaClient{cc}
}

func (c *quotaClient) ListQuotas(ctx context.Context, in *v1alpha15.ListQuotasRequest, opts ...grpc.CallOption) (*v1alpha15.ListQuotasResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha15.ListQuotasResponse)
	err := c.cc.Invoke(ctx, Quota_ListQuotas_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quotaClient) DeleteQuota(ctx context.Context, in *v1alpha15.DeleteQuotaRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Quota_DeleteQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quotaClient) CreateQuota(ctx context.Context, in *v1alpha15.CreateQuotaRequest, opts ...grpc.CallOption) (*v1alpha15.QuotaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha15.QuotaResponse)
	err := c.cc.Invoke(ctx, Quota_CreateQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quotaClient) UpdateQuota(ctx context.Context, in *v1alpha15.UpdateQuotaRequest, opts ...grpc.CallOption) (*v1alpha15.QuotaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha15.QuotaResponse)
	err := c.cc.Invoke(ctx, Quota_UpdateQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *quotaClient) GetQuota(ctx context.Context, in *v1alpha15.GetQuotaRequest, opts ...grpc.CallOption) (*v1alpha15.QuotaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha15.QuotaResponse)
	err := c.cc.Invoke(ctx, Quota_GetQuota_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QuotaServer is the server API for Quota service.
// All implementations must embed UnimplementedQuotaServer
// for forward compatibility.
type QuotaServer interface {
	// ListQuotas lists resource quotas.
	ListQuotas(context.Context, *v1alpha15.ListQuotasRequest) (*v1alpha15.ListQuotasResponse, error)
	// DeleteQuota deletes a resource quota.
	DeleteQuota(context.Context, *v1alpha15.DeleteQuotaRequest) (*emptypb.Empty, error)
	// CreateQuota creates a resource quota.
	CreateQuota(context.Context, *v1alpha15.CreateQuotaRequest) (*v1alpha15.QuotaResponse, error)
	// UpdateQuota updates a resource quota.
	UpdateQuota(context.Context, *v1alpha15.UpdateQuotaRequest) (*v1alpha15.QuotaResponse, error)
	GetQuota(context.Context, *v1alpha15.GetQuotaRequest) (*v1alpha15.QuotaResponse, error)
	mustEmbedUnimplementedQuotaServer()
}

// UnimplementedQuotaServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQuotaServer struct{}

func (UnimplementedQuotaServer) ListQuotas(context.Context, *v1alpha15.ListQuotasRequest) (*v1alpha15.ListQuotasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListQuotas not implemented")
}
func (UnimplementedQuotaServer) DeleteQuota(context.Context, *v1alpha15.DeleteQuotaRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteQuota not implemented")
}
func (UnimplementedQuotaServer) CreateQuota(context.Context, *v1alpha15.CreateQuotaRequest) (*v1alpha15.QuotaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateQuota not implemented")
}
func (UnimplementedQuotaServer) UpdateQuota(context.Context, *v1alpha15.UpdateQuotaRequest) (*v1alpha15.QuotaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateQuota not implemented")
}
func (UnimplementedQuotaServer) GetQuota(context.Context, *v1alpha15.GetQuotaRequest) (*v1alpha15.QuotaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuota not implemented")
}
func (UnimplementedQuotaServer) mustEmbedUnimplementedQuotaServer() {}
func (UnimplementedQuotaServer) testEmbeddedByValue()               {}

// UnsafeQuotaServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QuotaServer will
// result in compilation errors.
type UnsafeQuotaServer interface {
	mustEmbedUnimplementedQuotaServer()
}

func RegisterQuotaServer(s grpc.ServiceRegistrar, srv QuotaServer) {
	// If the following call pancis, it indicates UnimplementedQuotaServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Quota_ServiceDesc, srv)
}

func _Quota_ListQuotas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha15.ListQuotasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServer).ListQuotas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Quota_ListQuotas_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServer).ListQuotas(ctx, req.(*v1alpha15.ListQuotasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Quota_DeleteQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha15.DeleteQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServer).DeleteQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Quota_DeleteQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServer).DeleteQuota(ctx, req.(*v1alpha15.DeleteQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Quota_CreateQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha15.CreateQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServer).CreateQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Quota_CreateQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServer).CreateQuota(ctx, req.(*v1alpha15.CreateQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Quota_UpdateQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha15.UpdateQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServer).UpdateQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Quota_UpdateQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServer).UpdateQuota(ctx, req.(*v1alpha15.UpdateQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Quota_GetQuota_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha15.GetQuotaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuotaServer).GetQuota(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Quota_GetQuota_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuotaServer).GetQuota(ctx, req.(*v1alpha15.GetQuotaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Quota_ServiceDesc is the grpc.ServiceDesc for Quota service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Quota_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.Quota",
	HandlerType: (*QuotaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListQuotas",
			Handler:    _Quota_ListQuotas_Handler,
		},
		{
			MethodName: "DeleteQuota",
			Handler:    _Quota_DeleteQuota_Handler,
		},
		{
			MethodName: "CreateQuota",
			Handler:    _Quota_CreateQuota_Handler,
		},
		{
			MethodName: "UpdateQuota",
			Handler:    _Quota_UpdateQuota_Handler,
		},
		{
			MethodName: "GetQuota",
			Handler:    _Quota_GetQuota_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}

const (
	Storage_ListStorageClasses_FullMethodName = "/kantaloupev1.Storage/ListStorageClasses"
	Storage_CreateStorage_FullMethodName      = "/kantaloupev1.Storage/CreateStorage"
	Storage_DeleteStorage_FullMethodName      = "/kantaloupev1.Storage/DeleteStorage"
	Storage_ListStorages_FullMethodName       = "/kantaloupev1.Storage/ListStorages"
)

// StorageClient is the client API for Storage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StorageClient interface {
	// ListStorageClasses lists storage classes.
	ListStorageClasses(ctx context.Context, in *v1alpha16.ListStorageClassesRequest, opts ...grpc.CallOption) (*v1alpha16.ListStorageClassesResponse, error)
	// CreateStorageClass creates a storage
	CreateStorage(ctx context.Context, in *v1alpha16.CreateStorageRequest, opts ...grpc.CallOption) (*v1alpha16.Storage, error)
	// DeleteStorage deletes a storage
	DeleteStorage(ctx context.Context, in *v1alpha16.DeleteStorageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListStorage lists specific namespace storage
	ListStorages(ctx context.Context, in *v1alpha16.ListStoragesRequest, opts ...grpc.CallOption) (*v1alpha16.ListStoragesResponse, error)
}

type storageClient struct {
	cc grpc.ClientConnInterface
}

func NewStorageClient(cc grpc.ClientConnInterface) StorageClient {
	return &storageClient{cc}
}

func (c *storageClient) ListStorageClasses(ctx context.Context, in *v1alpha16.ListStorageClassesRequest, opts ...grpc.CallOption) (*v1alpha16.ListStorageClassesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha16.ListStorageClassesResponse)
	err := c.cc.Invoke(ctx, Storage_ListStorageClasses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) CreateStorage(ctx context.Context, in *v1alpha16.CreateStorageRequest, opts ...grpc.CallOption) (*v1alpha16.Storage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha16.Storage)
	err := c.cc.Invoke(ctx, Storage_CreateStorage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) DeleteStorage(ctx context.Context, in *v1alpha16.DeleteStorageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Storage_DeleteStorage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageClient) ListStorages(ctx context.Context, in *v1alpha16.ListStoragesRequest, opts ...grpc.CallOption) (*v1alpha16.ListStoragesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha16.ListStoragesResponse)
	err := c.cc.Invoke(ctx, Storage_ListStorages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StorageServer is the server API for Storage service.
// All implementations must embed UnimplementedStorageServer
// for forward compatibility.
type StorageServer interface {
	// ListStorageClasses lists storage classes.
	ListStorageClasses(context.Context, *v1alpha16.ListStorageClassesRequest) (*v1alpha16.ListStorageClassesResponse, error)
	// CreateStorageClass creates a storage
	CreateStorage(context.Context, *v1alpha16.CreateStorageRequest) (*v1alpha16.Storage, error)
	// DeleteStorage deletes a storage
	DeleteStorage(context.Context, *v1alpha16.DeleteStorageRequest) (*emptypb.Empty, error)
	// ListStorage lists specific namespace storage
	ListStorages(context.Context, *v1alpha16.ListStoragesRequest) (*v1alpha16.ListStoragesResponse, error)
	mustEmbedUnimplementedStorageServer()
}

// UnimplementedStorageServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStorageServer struct{}

func (UnimplementedStorageServer) ListStorageClasses(context.Context, *v1alpha16.ListStorageClassesRequest) (*v1alpha16.ListStorageClassesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStorageClasses not implemented")
}
func (UnimplementedStorageServer) CreateStorage(context.Context, *v1alpha16.CreateStorageRequest) (*v1alpha16.Storage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStorage not implemented")
}
func (UnimplementedStorageServer) DeleteStorage(context.Context, *v1alpha16.DeleteStorageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStorage not implemented")
}
func (UnimplementedStorageServer) ListStorages(context.Context, *v1alpha16.ListStoragesRequest) (*v1alpha16.ListStoragesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStorages not implemented")
}
func (UnimplementedStorageServer) mustEmbedUnimplementedStorageServer() {}
func (UnimplementedStorageServer) testEmbeddedByValue()                 {}

// UnsafeStorageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StorageServer will
// result in compilation errors.
type UnsafeStorageServer interface {
	mustEmbedUnimplementedStorageServer()
}

func RegisterStorageServer(s grpc.ServiceRegistrar, srv StorageServer) {
	// If the following call pancis, it indicates UnimplementedStorageServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Storage_ServiceDesc, srv)
}

func _Storage_ListStorageClasses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha16.ListStorageClassesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).ListStorageClasses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Storage_ListStorageClasses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).ListStorageClasses(ctx, req.(*v1alpha16.ListStorageClassesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_CreateStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha16.CreateStorageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).CreateStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Storage_CreateStorage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).CreateStorage(ctx, req.(*v1alpha16.CreateStorageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_DeleteStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha16.DeleteStorageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).DeleteStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Storage_DeleteStorage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).DeleteStorage(ctx, req.(*v1alpha16.DeleteStorageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Storage_ListStorages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha16.ListStoragesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServer).ListStorages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Storage_ListStorages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServer).ListStorages(ctx, req.(*v1alpha16.ListStoragesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Storage_ServiceDesc is the grpc.ServiceDesc for Storage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Storage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.Storage",
	HandlerType: (*StorageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListStorageClasses",
			Handler:    _Storage_ListStorageClasses_Handler,
		},
		{
			MethodName: "CreateStorage",
			Handler:    _Storage_CreateStorage_Handler,
		},
		{
			MethodName: "DeleteStorage",
			Handler:    _Storage_DeleteStorage_Handler,
		},
		{
			MethodName: "ListStorages",
			Handler:    _Storage_ListStorages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}

const (
	AcceleratorCard_ListAcceleratorCard_FullMethodName = "/kantaloupev1.AcceleratorCard/ListAcceleratorCard"
	AcceleratorCard_GetAcceleratorCard_FullMethodName  = "/kantaloupev1.AcceleratorCard/GetAcceleratorCard"
	AcceleratorCard_ListModelNames_FullMethodName      = "/kantaloupev1.AcceleratorCard/ListModelNames"
)

// AcceleratorCardClient is the client API for AcceleratorCard service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AcceleratorCardClient interface {
	ListAcceleratorCard(ctx context.Context, in *v1alpha17.ListAcceleratorCardsRequest, opts ...grpc.CallOption) (*v1alpha17.ListAcceleratorCardsResponse, error)
	GetAcceleratorCard(ctx context.Context, in *v1alpha17.GetAcceleratorCardRequest, opts ...grpc.CallOption) (*v1alpha17.AcceleratorCard, error)
	ListModelNames(ctx context.Context, in *v1alpha17.ListModelNamesRequest, opts ...grpc.CallOption) (*v1alpha17.ListModelNamesResponse, error)
}

type acceleratorCardClient struct {
	cc grpc.ClientConnInterface
}

func NewAcceleratorCardClient(cc grpc.ClientConnInterface) AcceleratorCardClient {
	return &acceleratorCardClient{cc}
}

func (c *acceleratorCardClient) ListAcceleratorCard(ctx context.Context, in *v1alpha17.ListAcceleratorCardsRequest, opts ...grpc.CallOption) (*v1alpha17.ListAcceleratorCardsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha17.ListAcceleratorCardsResponse)
	err := c.cc.Invoke(ctx, AcceleratorCard_ListAcceleratorCard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acceleratorCardClient) GetAcceleratorCard(ctx context.Context, in *v1alpha17.GetAcceleratorCardRequest, opts ...grpc.CallOption) (*v1alpha17.AcceleratorCard, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha17.AcceleratorCard)
	err := c.cc.Invoke(ctx, AcceleratorCard_GetAcceleratorCard_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acceleratorCardClient) ListModelNames(ctx context.Context, in *v1alpha17.ListModelNamesRequest, opts ...grpc.CallOption) (*v1alpha17.ListModelNamesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1alpha17.ListModelNamesResponse)
	err := c.cc.Invoke(ctx, AcceleratorCard_ListModelNames_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AcceleratorCardServer is the server API for AcceleratorCard service.
// All implementations must embed UnimplementedAcceleratorCardServer
// for forward compatibility.
type AcceleratorCardServer interface {
	ListAcceleratorCard(context.Context, *v1alpha17.ListAcceleratorCardsRequest) (*v1alpha17.ListAcceleratorCardsResponse, error)
	GetAcceleratorCard(context.Context, *v1alpha17.GetAcceleratorCardRequest) (*v1alpha17.AcceleratorCard, error)
	ListModelNames(context.Context, *v1alpha17.ListModelNamesRequest) (*v1alpha17.ListModelNamesResponse, error)
	mustEmbedUnimplementedAcceleratorCardServer()
}

// UnimplementedAcceleratorCardServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAcceleratorCardServer struct{}

func (UnimplementedAcceleratorCardServer) ListAcceleratorCard(context.Context, *v1alpha17.ListAcceleratorCardsRequest) (*v1alpha17.ListAcceleratorCardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAcceleratorCard not implemented")
}
func (UnimplementedAcceleratorCardServer) GetAcceleratorCard(context.Context, *v1alpha17.GetAcceleratorCardRequest) (*v1alpha17.AcceleratorCard, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAcceleratorCard not implemented")
}
func (UnimplementedAcceleratorCardServer) ListModelNames(context.Context, *v1alpha17.ListModelNamesRequest) (*v1alpha17.ListModelNamesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListModelNames not implemented")
}
func (UnimplementedAcceleratorCardServer) mustEmbedUnimplementedAcceleratorCardServer() {}
func (UnimplementedAcceleratorCardServer) testEmbeddedByValue()                         {}

// UnsafeAcceleratorCardServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AcceleratorCardServer will
// result in compilation errors.
type UnsafeAcceleratorCardServer interface {
	mustEmbedUnimplementedAcceleratorCardServer()
}

func RegisterAcceleratorCardServer(s grpc.ServiceRegistrar, srv AcceleratorCardServer) {
	// If the following call pancis, it indicates UnimplementedAcceleratorCardServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AcceleratorCard_ServiceDesc, srv)
}

func _AcceleratorCard_ListAcceleratorCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha17.ListAcceleratorCardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceleratorCardServer).ListAcceleratorCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcceleratorCard_ListAcceleratorCard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceleratorCardServer).ListAcceleratorCard(ctx, req.(*v1alpha17.ListAcceleratorCardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcceleratorCard_GetAcceleratorCard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha17.GetAcceleratorCardRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceleratorCardServer).GetAcceleratorCard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcceleratorCard_GetAcceleratorCard_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceleratorCardServer).GetAcceleratorCard(ctx, req.(*v1alpha17.GetAcceleratorCardRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcceleratorCard_ListModelNames_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1alpha17.ListModelNamesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceleratorCardServer).ListModelNames(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcceleratorCard_ListModelNames_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceleratorCardServer).ListModelNames(ctx, req.(*v1alpha17.ListModelNamesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AcceleratorCard_ServiceDesc is the grpc.ServiceDesc for AcceleratorCard service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AcceleratorCard_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "kantaloupev1.AcceleratorCard",
	HandlerType: (*AcceleratorCardServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAcceleratorCard",
			Handler:    _AcceleratorCard_ListAcceleratorCard_Handler,
		},
		{
			MethodName: "GetAcceleratorCard",
			Handler:    _AcceleratorCard_GetAcceleratorCard_Handler,
		},
		{
			MethodName: "ListModelNames",
			Handler:    _AcceleratorCard_ListModelNames_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/kantaloupe.proto",
}
